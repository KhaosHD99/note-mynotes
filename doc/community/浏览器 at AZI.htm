<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- saved from url=(0028)http://173.234.53.177/?cat=8 -->
<HTML lang=zh-CN dir=ltr xmlns="http://www.w3.org/1999/xhtml"><HEAD 
profile=http://gmpg.org/xfn/11><TITLE>浏览器 at AZI</TITLE>
<META http-equiv=Content-Type content="text/html; charset=UTF-8">
<META content=移动的技术 name=description>
<META content="MSHTML 6.00.2900.6129" name=GENERATOR><!-- leave this for stats please --><LINK media=screen 
href="浏览器 at AZI.files/style.css" type=text/css rel=stylesheet><LINK 
title="AZI RSS Feed" href="http://173.234.53.177/?feed=rss2" 
type=application/rss+xml rel=alternate><LINK 
href="http://173.234.53.177/wp-content/themes/journalist/favicon.png" 
type=image/x-png rel="shortcut icon"><LINK 
href="http://173.234.53.177/xmlrpc.php" rel=pingback><LINK 
title="AZI » 浏览器 分类目录 feed" href="http://173.234.53.177/?feed=rss2&amp;cat=8" 
type=application/rss+xml rel=alternate><LINK title=RSD 
href="http://173.234.53.177/xmlrpc.php?rsd" type=application/rsd+xml 
rel=EditURI><LINK href="http://173.234.53.177/wp-includes/wlwmanifest.xml" 
type=application/wlwmanifest+xml rel=wlwmanifest><LINK title=AZI 
href="http://173.234.53.177" rel=index>
<META content="WordPress 3.1.3" name=generator></HEAD>
<BODY>
<DIV class=group id=container>
<H1><A href="http://173.234.53.177/">AZI</A></H1>
<DIV id=bubble>
<P>移动的技术</P></DIV><!-- erase this line if you want to turn the bubble off -->
<DIV id=content>
<H2 class=archive>Archive for the ‘浏览器’ Category</H2>
<H2 id=post-99><A href="http://173.234.53.177/?p=99" 
rel=bookmark>最早的22个标签</A></H2>
<P class=comments><A href="http://173.234.53.177/?p=99#comments">without 
comments</A></P>
<DIV class=main>
<H1><A 
href="http://www.w3.org/History/19921103-hypertext/hypertext/WWW/MarkUp/Tags.html">http://www.w3.org/History/19921103-hypertext/hypertext/WWW/MarkUp/Tags.html</A></H1>
<H1>HTML Tags</H1>
<P>This is a list of tags used in the&nbsp;<A 
href="http://www.w3.org/History/19921103-hypertext/hypertext/WWW/MarkUp/MarkUp.html#4" 
name=0>HTML</A> language. Each tag starts with a tag opener (a less than sign) 
and ends with a tag closer (a greater than sign). Many tags have corresponding 
closing tags which identical except for a slash after the tag opener. (For 
example, the<A 
href="http://www.w3.org/History/19921103-hypertext/hypertext/WWW/MarkUp/Tags.html#2" 
name=3> TITLE</A> tag).</P>
<P>Some tags take parameters, called attributes. The attributes are given after 
the tag, separated by spaces. Certain attributes have an effect simply by their 
presence, others are followed by an equals sign and a value. (See the&nbsp;<A 
href="http://www.w3.org/History/19921103-hypertext/hypertext/WWW/MarkUp/Tags.html#4" 
name=5>Anchor</A> tag, for example). The names of tags and attributes are not 
case sensitive: they may be in lower, upper, or mixed case with exactly the same 
meaning. (In this document they are generally represented in upper case.)</P>
<P>Currently HTML documents are transmitted without the normal SGML framing 
tags, but if these are included parsers will ignore them.</P>
<H2><A name=2>Title</A></H2>
<P>The title of a document is given between title tags: &amp;lt;TITLE&amp;gt; … 
&amp;lt;/TITLE&amp;gt; The text between the opening and the closing tags is a 
title for the hypertext node. There should only be one title in any node. It 
should identify the content of the node in a fairly wide context, and should 
ideally fit on one line.</P>
<P>The title is not strictly part of the text of the document, but is an 
attribute of the node. It may not contain anchors, paragraph marks, or 
highlighting. the title may be used to identify the node in a history list, to 
label the window displaying the node, etc. It is not normally displayed in the 
text of a document itself. Contrast titles with&nbsp;<A 
href="http://www.w3.org/History/19921103-hypertext/hypertext/WWW/MarkUp/Tags.html#15" 
name=16>headings</A> .</P>
<H2>Next ID</H2>
<P>Obsolete: NeXT Browser only. May be ignored. This tag takes a single 
attribute which is the number of the next document-wide numeric identifier to be 
allocated (not good SGML). Note that when modifying a document, old anchor ids 
should not be reused, as there may be references stored elsewhere which point to 
them. This is read and generated by hypertext editors. Human writers of HTML 
usually use mnemonic alpha identifiers. Browser software may ignore this tag. 
Example of use: &amp;lt;NEXTID 27&amp;gt;</P>
<H2><A name=11>Base Address</A></H2>
<P><A 
href="http://www.w3.org/History/19921103-hypertext/hypertext/WWW/MarkUp/Tags.html#4" 
name=9>Anchors</A> specify addresses of other documents, in a from relative to 
the address of the current document. Normally, the address of a document is 
known to the browser because it was used to access the document. However, is a 
document is mailed, or is somehow visible with more than one address (for 
example, via its filename and also via its library name server catalogue 
number), then the browser needs to know the base address in order to correctly 
deduce external document addresses.</P>
<P>The format of this tag is not yet specified. NOT CURRENTLY USED</P>
<H2><A name=4>Anchors</A></H2>
<P>The format of an anchor is as follows: &amp;lt;A NAME=xxx HREF=XXX&amp;gt; … 
&amp;lt;/A&amp;gt; The text between the opening tag and the closing tag is 
either the start or destination (or both) of a link. Attributes of the anchor 
tag are as follows.</P>
<DL>
  <DT><A name=13>HREF</A> 
  <DD>If the HREF attribute is present, the anchor is senstive text: the start 
  of a link. If the reader selects this text, he should be presented with 
  another document whose network address is defined by the value of the HREF 
  attribute . The format of the network address is specified&nbsp;<A 
  href="http://www.w3.org/History/19921103-hypertext/hypertext/WWW/Addressing/Addressing.html" 
  name=10>elsewhere</A> . This allows for the form HREF=#identifier to refer to 
  another anchor in the same document. If the anchor is in another document, the 
  atribute is a&nbsp;<A 
  href="http://www.w3.org/History/19921103-hypertext/hypertext/WWW/Addressing/Relative.html" 
  name=14>relative name</A> , relative to the documents address (or 
  specified&nbsp;<A 
  href="http://www.w3.org/History/19921103-hypertext/hypertext/WWW/MarkUp/Tags.html#11" 
  name=12>base address</A> if any). 
  <DT>NAME 
  <DD>The attribute NAME allows the anchor to be the destination of a link. The 
  value of the parameter is that part of a hypertext address which follows the<A 
  href="http://www.w3.org/History/19921103-hypertext/hypertext/WWW/Addressing/BNF.html#21" 
  name=19>hash sign</A> . 
  <DT><A name=21>TYPE</A> 
  <DD>An attribute TYPE may give the relationship described by the hyertext 
  link. The type is expressed by a string for extensibility. Strings for types 
  with particular semantics will be registered by the W3 team. The default 
  relationship if none other is given is void. </DD></DL>
<P>All attributes are optional, although one of NAME and HREF is necessary for 
the anchor to be useful.</P>
<H2><A name=18>IsIndex</A></H2>
<P>This tag informs the reader that the document is an index document. As well 
as reading it, the reader may use a keyword search.</P>
<P>Format:</P>
<P>&amp;lt;ISINDEX&amp;gt; The node may be queried with a keyword search by 
suffixing the node address with a question mark, followed by a list of keywords 
separated by plus signs. See the&nbsp;<A 
href="http://www.w3.org/History/19921103-hypertext/hypertext/WWW/Addressing/Search.html" 
name=1>network address format</A> .</P>
<H2><A name=7>Plaintext</A></H2>
<P>This tag indicates that all following text is to be taken litterally, up to 
the end of the file. Plain text is designed to be represented in the same way as 
example XMP text, with fixed width character and significant line breaks. 
Format: &amp;lt;PLAINTEXT&amp;gt; This tag allows the rest of a file to be read 
efficiently without parsing. Its presence is an optimisation. There is no 
closing tag.</P>
<H2><A name=8>Example sections</A></H2>
<P>These styles allow text of fixed-width characters to be embedded absolutely 
as is into the document. The format is: &amp;lt;LISTING&amp;gt; … 
&amp;lt;/LISTING&amp;gt; The text between these tags is to be portrayed in a 
fixed width font, so that any formatting done by character spacing on successive 
lines will be maintained. Between the opening and closing tags:</P>
<UL>
  <LI>The text may contain any ISO Latin printable characters, including the tag 
  opener, so long as it does not contain the closing tag in full. 
  <LI>Line boundaries are significant, and are to be interpreted as a move to 
  the start of a new line. 
  <LI>The ASCII Horizontal Tab (HT) character should be interpreted as the 
  smallest positive nonzero number of spaces which will leave the number of 
  characters so far on the line as a multiple of 8. Its use is not recommended 
  however. </LI></UL>
<P>The LISTING tag is portrayed so that at least 132 characters will fit on a 
line. The XMP tag is portrayed in a font so that at least 80 characters will fit 
on a line but is otherwise identical to LISTING. The examples of markup are here 
given using the XMP tag.</P>
<H2>Paragraph</H2>
<P>This tag indicates a new paragraph. The exact representation of this 
(indentation, leading, etc) is not defined here, and may be a function of other 
tags, style sheets etc. The format is simply &amp;lt;P&amp;gt; (In SGML terms, 
paragraph elements are transmitted in minimised form).</P>
<H2><A name=15>Headings</A></H2>
<P>Several levels (at least six) of heading are supported. Note that a hypertext 
document tends to need less levels of heading than a normal document whose only 
structure is given by the nesting of headings. H1 is the highest level of 
heading, and is recommened for the start of a hypertext node. It is suggested 
that the first heading be one suitable for a reader who is already browsing in 
related information, in contrast to the&nbsp;<A 
href="http://www.w3.org/History/19921103-hypertext/hypertext/WWW/MarkUp/Tags.html#2" 
name=6>title</A> tag which should identify the node in a wider context. 
&amp;lt;H1&amp;gt;, &amp;lt;H2&amp;gt;, &amp;lt;H3&amp;gt;, &amp;lt;H4&amp;gt;, 
&amp;lt;H5&amp;gt;, &amp;lt;H6&amp;gt; These tags are kept as defined in the 
CERN SGML guide. Their definition is completely historical, deriving from 
the&nbsp;<A 
href="http://www.w3.org/History/19921103-hypertext/hypertext/WWW/MarkUp/AAP.html" 
name=17>AAP</A> tag set. A difference is that HTML documents allow headings to 
be terminated by closing tags: &amp;lt;H2&amp;gt;Second level 
heading&amp;lt;/h2&amp;gt;</P>
<H2><A name=20>Address</A></H2>
<P>This tag is for address information, signatures, etc, normally at the top or 
bottom of a document. typically, it is italic and/or right justified or 
indented. The format is: &amp;lt;ADDRESS&amp;gt; text … 
&amp;lt;/ADDRESS&amp;gt;</P>
<H2>Highlighting</H2>
<P>The highlighted phrase tags may occur in normal text, and may be nested. For 
each opening tag there must follow a corresponding closing tag. NOT CURRENTLY 
USED. &amp;lt;HP1&amp;gt;…&amp;lt;/HP1&amp;gt; &amp;lt;HP2&amp;gt;… 
&amp;lt;/HP2&amp;gt; etc.</P>
<H2>Glossaries</H2>
<P>A glosary (or definition list) is a list of paragraphs each of which has a 
short title alongside it. Apart from glossaries, this format is useful for 
presenting a set of named elements to the reader. The format is as follows: 
&amp;lt;DL&amp;gt; &amp;lt;DT&amp;gt;Term&amp;lt;DD&amp;gt;definition pagagraph 
&amp;lt;DT&amp;gt;Term2&amp;lt;DD&amp;gt;Definition of term2 
&amp;lt;/DL&amp;gt;</P>
<H2>Lists</H2>
<P>A list is a sequence of paragraphs, each of which is preceded by a special 
mark or sequence number. The format is: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; 
list element &amp;lt;LI&amp;gt; another list element … &amp;lt;/UL&amp;gt; The 
opening list tag must be immediately followed by the first list element. The 
representation of the list is not defined here, but a bulleted list for 
unordered lists, and a sequence of numbered paragraphs for an ordered list would 
be quite appropriate. Other possibilities for interactive display include 
embedded scrollable browse panels.</P>
<P>Opening list tags are:</P>
<DL>
  <DT>UL 
  <DD>A list multi-line paragraphs, typically separated by some white space. 
  <DT>MENU 
  <DD>A list of smaller paragraphs. Typically one line per item, with a style 
  more compact than UL. 
  <DT>DIR 
  <DD>A list of short elements, less than one line. Typical style is to arrange 
  in four columns or provide a browser, etc. </DD></DL>
<P>the closing tag must obviously match the opening tag.</P>
<P>&nbsp;</P></DIV>
<DIV class="meta group">
<DIV class=signature>
<P>Written by admin <SPAN class=edit></SPAN></P>
<P>三月 26th, 2011 at 6:10 上午</P></DIV>
<DIV class=tags>
<P>Posted in <A title="查看 浏览器 的全部文章" href="http://173.234.53.177/?cat=8" 
rel=category>浏览器</A></P></DIV></DIV>
<H2 id=post-97><A href="http://173.234.53.177/?p=97" 
rel=bookmark>IE9网络性能改进及策略</A></H2>
<P class=comments><A href="http://173.234.53.177/?p=97#comments">without 
comments</A></P>
<DIV class=main>
<P>IE9 RTM发布了，筒子们可以下载下来尝尝鲜。业界这次给了IE9比较大的期望值，祝愿微软可以籍此摆脱IE声名狼藉的现状。</P>
<P>IE9的目标是“更快，更安全和更好的用户体验”，在性能方面这次IE9下了很大功夫，IE的官方blog也不遗余力地进行这方面的宣传，今天发布了一篇关于IE9&nbsp;网络性能改进的文章，从这篇文章我们可以看出IE在网络性能方面的优化策略和思路。</P>
<P>地瓜曾经设计过轻量级浏览器的内核，在网络方面有过一定的研究，这篇文章里面讲到了很多问题，地瓜都曾经经历过，因此看到这篇文章，很有感触，仿佛回到了几年前。总体来说，浏览器发展到现在，网络优化的空间已经不大，现在的很多优化的手段，其实都是一种投机行为（说好听点，就是人工智能）。</P>
<P>当浏览器load一个网页的时候，一般包括几个步骤：1）如果电脑没有使用Web proxy，浏览器首先要进行DNS查询，也就是将<A 
href="http://www.microsoft.xn--com65-108h91unyw5wcm7qvk2beq3dmfb.55.12.xn--249ip-yb4kv04fi48b/">http://www.microsoft.xn--com65-108h91unyw5wcm7qvk2beq3dmfb.55.12.xn--249ip-yb4kv04fi48b/</A>地址，然后再同这个ip地址建立tcp连接。2）如果电脑使用Web 
proxy，浏览器首先找到proxy（有可能直接在设置中指定了，或者通过&nbsp;WPAD指定），如果proxy使用域名，先进行DNS查询，然后建立tcp连接。3）如果是安全连接（HTTPS），还需要进行SSL或者TLS的握手。握手中可能产生一次或者多次额外的用于证书鉴权的网络请求。4）连接建立后，浏览器发送HTTP请求给服务器。5）服务器收到请求后，产生响应数据，传回给浏览器。6）如果响应是HTML文件，通常这个HTML会包含其它资源（如图片，脚本，css）的引用，为了完全显示网页，浏览器重复执行之前的步骤来下载所需的资源。</P>
<P>从上面这几个步骤来看，优化的思路无非如下几个1）有多个资源下载的话，是否可以将一些串行操作改变成并行操作2）是否可以减少HTTP请求3）减少DNS查询的时间4）减少建立TCP连接的时间。</P>
<P>HTTP协议中对减少TCP连接的时间有自己的策略，比如说永久连接和pipeline，但是地瓜通过对IE抓包来看，ie并没有采用永久连接和pipeline。对于减少HTTP请求，HTTP协议中有Cache的机制。</P>
<P>IE9主要的提高在于1，2，3点。</P>
<P>首先是从DNS查询时间做起，IE9有了些投机起巧的策略。</P>
<P>1）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当用户通过地址栏输入网址的时候，输完3个字符，&nbsp;IE9会马上发起下拉框中前五个备选网站的dns&nbsp;查询，并将其存到本地操作系统缓存中备用。这样的话，如果用户之后访问到这些域名，浏览器可以减少等待dns查询结果的时间。</P>
<P>2）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对访问过的网站进行猜测性DNS预查询。当用户访问过一个网页的时候，IE9会在网页的历史记录中记录下使用那个网页需要访问的域名。比如，在loading 
IEBlog的时候，HTML引用了五个其它的站点（i.msdn.miscrosoft.com,<BR>cdn-smooth.ms-studiosmedia.com,go.miscrosoft.com,ieblog.members.winisp.net和silverlight.dlservice.microsoft.com），所以当用户访问IEBlog，创建到blogs.msdn.com的tcp连接的时候，IE9会并行发起这几个域名的dns解析请求。</P>
<P>对于并行操作，一般一个网页对每个域名会创建超过一个的HTTP 
connection。IE9在创建第一个连接的时候并行打开了一个后台连接（background 
connection）。这样下一个HTTP请求就不用等待连接建立的过程了。一个host只允许建立一个后台连接。（地瓜：这种方式其实加重了服务器的负担）。</P>
<P>另外，IE9之前的版本已经提出了lookahead 
downloader的下载策略，也就是下载完HTML之后，立即对它进行扫描，寻找之后可能需要下载的资源（毫无疑问，javascript文件具有最高优先级），这个扫描开始于页面解析之前。然后在页面解析的同时，就可以并行发起这些投机性的下载，为什么说它是投机性下载呢，因为页面解析之后，可能javascript就会remove掉这些需要发起下载的标签。但是，这种情况毕竟不经常发生，即使发生，除了损失一点性能之外没有其它的害处。</P>
<P>在缓存方面，IE9在缓存实现算法上有所改进，之前的版本，IE缺省地将Web内容缓存大小限制为硬盘大小的1/32，IE7,IE8缺省的是50M。限制这么小的一个坏处是如果达到这个容量，经常需要进行缓存淘汰。之前的版本通过测试，设置大了并不能显著提高缓存命中比率。而且需要更长时间的枚举和清理。但是，IE9重新审视了这个测试结论，并改进了一些算法，解决了一些相关问题以后，更大的缓存大小设置就可以带来更好的命中率。所以IE9将缺省的缓存大小设置为硬盘大小的1/32（考虑到硬盘容量变大）以及250M。从这里，我们可以发现，缓存大小的设置，影响网页加载速度，筒子们可以Tools-&gt;Internet 
Options-&gt;GeneralàBrowsing History Settings dialog 
box修改。当然，缓存大小设置也有限制，因为缓存条目有６０００条的限制，如果设置太大了，就会先达到条目的限制，没有意义。</P>
<P>缓存清理工作。很久以前，地瓜在手机上实现ＨＴＴＰ协议，当时一直在考虑如何指定合理的缓存淘汰算法。通过这篇博客，我们看到了IE9的缓存淘汰算法。</P>
<P>首先，缓存淘汰算法的目标是当缓存到达它的大小或者条目限制的时候，清理掉至少１０%的缓存。</P>
<P>IE9对缓存对象维护一个打分系统，对所有缓存对象进行打分，分值最低的10%条目会被清理掉。计算分值的时候，总分是66000，器重40000是由指定资源最近一次访问的时间确定（最近访问的条目分值高），2000分由资源访问的频率决定(经常访问的条目分高)，6000分来自于缓存校验信息(validator 
information，像Last-Modified和Etag这样的响应头部)是否存在，这些校验信息允许对资源在到期后进行条件请求和校验。资源的ＭＩＭＥ类型也会在分值计算中得到反应，script,CSS和HTML/XHTML资源获取全部分数，而images,audio等获取指定分数的一半（其实是根据不同资源对页面下载时间的影响作出的决策）。那些使用超过一词的缓存条目得到增加的重用分。为了获取10000重用分，资源必须在超过12个小时的时间段被重复使用(这避免了资源在一个很短时间频繁访问，比如那些从长期看你很少上的网站)。有validator的条目可以获取validator分数，当然，最大的影响是资源是否还新鲜。那些过期且没有validators的条目会得０分，有validator的可以获取70%的分数。</P>
<P>另外，IE9中包含了新的Tracking 
Protectiong和ActiveX过滤功能，这两个功能通过阻止下载和执行未要求的内容，也可以提高总的浏览器性能。</P>
<P>&nbsp;</P>
<P>参考</P>
<P>1）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://blogs.msdn.com/b/ie/archive/2011/03/17/internet-explorer-9-network-performance-improvements.aspx">Internet 
Explorer 9 Network Performance Improvements</A> ，<BR><A 
href="http://blogs.msdn.com/b/ie/archive/2011/03/17/internet-explorer-9-network-performance-improvements.aspx">http://blogs.msdn.com/b/ie/archive/2011/03/17/internet-explorer-9-network-performance-improvements.aspx</A></P>
<P>2）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bugs in IE8′s 
Lookahead Downloader，</P>
<P><A 
href="http://blogs.msdn.com/b/ieinternals/archive/2009/07/27/bugs-in-the-ie8-lookahead-downloader.aspx">http://blogs.msdn.com/b/ieinternals/archive/2009/07/27/bugs-in-the-ie8-lookahead-downloader.aspx</A></P>
<P>3）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://blog.chromium.org/2008/09/dns-prefetching-or-pre-resolving.html">DNS 
Prefetching (or Pre-Resolving)</A> ,<BR><A 
href="http://blog.chromium.org/2008/09/dns-prefetching-or-pre-resolving.html">http://blog.chromium.org/2008/09/dns-prefetching-or-pre-resolving.html</A></P>
<P>&nbsp;</P></DIV>
<DIV class="meta group">
<DIV class=signature>
<P>Written by admin <SPAN class=edit></SPAN></P>
<P>三月 26th, 2011 at 6:09 上午</P></DIV>
<DIV class=tags>
<P>Posted in <A title="查看 浏览器 的全部文章" href="http://173.234.53.177/?cat=8" 
rel=category>浏览器</A></P></DIV></DIV>
<H2 id=post-94><A href="http://173.234.53.177/?p=94" 
rel=bookmark>WebKit内核源代码分析（三）</A></H2>
<P class=comments><A href="http://173.234.53.177/?p=94#comments">without 
comments</A></P>
<DIV class=main>
<P>摘要：浏览器的请求一般是以页面请求为单位，当用户通过网址栏输入一个url，浏览器就开始一个页面请求。而一个页面请求可能包含有一到多个页面子帧，以及图片、CSS和插件等派生子资源。Page类就是用来对应这样的页面请求。Page类是WebKit中非常重要的一个类，它就像内核对外的一个聚合器。</P>
<P>关键词:WebKit内核源代码,WebCore,Page,Frame，WebKit架构</P>
<H2>1.&nbsp;&nbsp;&nbsp;&nbsp;概述</H2>
<P>浏览器的请求一般是以页面请求为单位，当用户通过网址栏输入一个url，浏览器就开始一个页面请求。而一个页面请求可能包含有一到多个页面子帧，以及图片、CSS和插件等派生子资源。Page类就是用来对应这样的页面请求。前进后退，导航，编辑，右键菜单，设置，Inspector等这些用户参与的动作，大部分是同Page相关的。而标记语言解析、排版、加载则更多地同Frame相关。</P>
<P>我们通过几个图来看下Qt移植中Page类同应用之间的关系。</P>
<P>&nbsp;</P>
<P><IMG alt="" src="浏览器 at AZI.files/0_1299648672b0K9.gif"></P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>QWebPage通过QWebPagePrivate维护Page类的指针，并在QWebPagePrivate的构造函数中实例化Page对象。QWebPage类通过之后的createMainFrame调用实例化QwebFrame，而在QwebFrameData的构造函数中，以Page指针为参数调用了Frame::create&nbsp;创建出Frame对象。</P>
<P>&nbsp;</P>
<P><IMG height=207 alt="" src="浏览器 at AZI.files/0_1299648680RXJs.gif" 
width=698></P>
<P>&nbsp;</P>
<P>Page类通过组合其它类的方式，实现了很多功能，Page类本身并没有多少代码。</P>
<H2>2.&nbsp;&nbsp;&nbsp;&nbsp;类关系</H2>
<H2><IMG height=764 alt="" src="浏览器 at AZI.files/0_1299648661Mm8q.gif" 
width=743></H2>
<H2>2.1&nbsp;&nbsp;PageGroup</H2>
<P>PageGroup并不是用来对Page进行管理的，而是设计用来将一些具有共同的属性或者设置的Page编成组的，以方便对这些属性进行管理。目前这样的属性包括localStorage的属性，IndexDB，User 
Script，User 
StyleSheet等。最常见的同PageGroup相关的操作是维护已访问链接（如addVisitedLink等接口）。根据地瓜的理解，假设WebKit内核之上架设多个应用（浏览器是一个应用），比较可能的是，一个应用独立一个PageGroup。这里同多tab页没有关系，多tab页属于同一个PageGroup。地瓜曾在mailing 
group上就这个问题咨询过，一位RIM的同学给我举了一个例子，比如一个基于WebKit的邮件程序，一方面他可能调用基于webkit的browser来显示网页，另外他本身也基于webkit来显示一些邮件，这两个之间的setting有很大可能不一样，他们就使用不同的PageGroup。</P>
<P>PageGroup中有这个Group已经安装并且使用的User Script和User StyleSheet的集合，一般在网页解析完毕后，这些User 
Script和User StyleSheet会插入到Document中。</P>
<P>PageGroup中还维护了Local Storage和Index 
DB相关的设置，比如它们的Path，上限等，通过GroupSettings类实现。</P>
<P>PageGroup创建以后，每次创建一个新的Page对象，会通过addPage接口加入到这个PageGroup的m_pages中。</P>
<P>每次有导航行为发生的时候，会调用addVisitedLink来将url加入到已访问链接中。如果浏览器要跟踪已访问的接口，则在初始化的时候必须调用PageGroup::setShouldTrackVisitedLinks，且参数为true。此处shouldTrackVisitedLinks是一个静态的全局变量，也就是说，所有应用维护一样的行为（一个应用将其设置为false会影响到其它同样基于此核的应用）？</P>
<P>Page类中维护了PageGroup的指针，并提供了group接口，这是个lazy接口，如果m_group不存在，会调用InitGroup来创建一个。对于Page类来说，如果没有设置GroupName，则在初始化的时候会生成一个空GroupName的PageGroup，由m_singlePageGroup维护，并把指针赋给m_group，如果以非空的名字调用了setGroupName，则会重新创建PageGroup，此时这个PageGroup由m_group来维护。</P>
<H3>2.2&nbsp;&nbsp;Setting</H3>
<P>WebCore中的设置相关的类，浏览器应用的不少配置、选项同该类相关，Qt移植中，应用在创建Page对象后，会根据Page::settings来实例化QwebSetting。</P>
<H3>2.3&nbsp;&nbsp;Chrome</H3>
<P>原生窗口接口类，参考地瓜写的”WebKit中的Chrome和ChromeClient”。</P>
<H3>2.4&nbsp;&nbsp;其它</H3>
<P>SelectionController 
:负责管理Page中的选取操作，绝大部分选取操作是基于Frame的，只在Frame的Selection为空的时候，对焦点游标的绘制工作才会使用到Page类的SelectionController。</P>
<P>SharedGraphicsContext3D:共享3D图形上下文，为了优化2D显示而加入。在加速的2D 
canvas中，引入的DrawingBuffer的概念，SharedGraphicsContext3D提供了createDrawingBuffer来创建DrawingBuffer。</P>
<P>DragController:拖拽控制器。Chrome的超级拖拽功能同这个有关？地瓜会在以后对此进行求证。</P>
<P>FocusController:焦点控制器。考虑到焦点会在各个frame之间切换，所以由Page类维护焦点控制器最合适不过。</P>
<P>ContextMenuController:右键下拉菜单控制器。</P>
<P>InspectorController:Inspector控制器，浏览器中的很多开发工具都同这个类相关。</P>
<P>GeolocationController:定位定位服务控制器。</P>
<P>DeviceMotionController:设备移动控制器</P>
<P>DeviceOrientationController:设备方向控制器</P>
<P>SpeechInputClient:语音输入Client。</P>
<P>ProgressTracker:进度跟踪。</P>
<P>BackForwardController:前进后退操作控制。</P>
<P>Frame:一个Page由至少一个主帧和若干个其它子帧构成。</P>
<P>HistoryItem:历史记录。</P>
<P>PluginData:插件相关，未来可能同PluginDatabase类合并。主要是初始化Plugin的信息。</P>
<P>PluginHalter:用来控制Plugin的停止和重新开始。</P>
<P>RenderTheme:这个类提供了控件的渲染和绘制接口。Qt移植中，RenderThemeQt是RenderTheme接口的具体实现。</P>
<P>EditorClient:同编辑功能相关，比如拷贝、剪切、删除等操作。</P>
<P>&nbsp;</P></DIV>
<DIV class="meta group">
<DIV class=signature>
<P>Written by admin <SPAN class=edit></SPAN></P>
<P>三月 26th, 2011 at 6:04 上午</P></DIV>
<DIV class=tags>
<P>Posted in <A title="查看 浏览器 的全部文章" href="http://173.234.53.177/?cat=8" 
rel=category>浏览器</A></P></DIV></DIV>
<H2 id=post-91><A href="http://173.234.53.177/?p=91" 
rel=bookmark>现代浏览器揭秘</A></H2>
<P class=comments><A href="http://173.234.53.177/?p=91#comments">without 
comments</A></P>
<DIV class=main>
<H4>要讨论的浏览器</H4>
<P>今天，人们主要使用5种浏览器：Internet 
Explorer、Firefox、Safari、Chrome和Opera。这篇文章的分析源自开源浏览器——Firefox、Chrome和Safari，Safari是部分开源的。根据W3C对浏览器使用情况的统计信息，当前（2009年10）Firefox、Safari和Chrome共同的市场占有率已接近60%。因此，可以说开源浏览器已经占据了浏览器市场的半壁江山。</P>
<H4>浏览器的主要功能</H4>
<P>浏览器的主要功能就是呈现你选择的网络资源，换句话说，就是你向服务器请求资源，然后浏览器把这些浏览器显示在浏览器的窗口中。资源的格式通常是HTML，当然也有PDF、图像等等。资源的位置是使用URI（Uniform 
Resource Indentifier，统一资源标识符）来指定的。与此相关的内容在后面讨论网络的时候还会详细介绍。</P>
<P>浏览器如何解释HTML文件是由HTML和CSS规范规定的。这些规范由W3C（World Wide Web 
Consortium，万维网联盟）维护的，W3C是负责制定Web标准的组件。</P>
<P>HTML当前的版本号是4（<A 
href="http://www.w3.org/TR/html401/ï¼ï¼HTML5è¿å¨å¶å®ä¸&shy;ãCSSå½åççæ¬å·æ¯2ï¼http://www.w3.org/TR/CSS2/ï¼ï¼CSS3ä¹æ&shy;£å¨å¶å®è¿ç¨ä¸&shy;ã">http://www.w3.org/TR/html401/ï¼ï¼HTML5è¿å¨å¶å®ä¸&shy;ãCSSå½åççæ¬å·æ¯2ï¼http://www.w3.org/TR/CSS2/ï¼ï¼CSS3ä¹æ&shy;£å¨å¶å®è¿ç¨ä¸&shy;ã</A></P>
<P>多少年来，浏览器厂商各自为战，纷纷埋头开发自己的扩展，对规范的支持始终不给力。结果就给Web开发人员带来了生死攸关的兼容性问题。而今天，大多数浏览器对规范的支持程度仍然参差不齐。</P>
<P>浏览器的用户界面大同小异，其中相同的界面元素包括：</P>
<UL>
  <LI>用于输入URI的地址栏 
  <LI>后退和前进按钮 
  <LI>书签选项 
  <LI>用于刷新和停止加载当前文档的刷新及停止按钮 
  <LI>返回主页的主页按钮 </LI></UL>
<P>说来也怪，并没有哪个正式公布的规范对浏览器的用户界面作出规定，浏览器目前的外观是多年来浏览器厂商之间互相模仿和不断改进的结果。HTML5规范中没有定义浏览器必须具备的UI元素，但列出了一些公共元素，其中就包括地址栏、状态栏和工具栏。当然，有些浏览器还有自己专有的一些功能，如Firefox的下载管理器。相关的更多内容将在后面讨论用户界面时介绍。</P>
<H4>浏览器的主要构成</H4>
<P>以下是构成浏览器的主要组件（见图1.1）。<BR>1、用户界面——包括地址栏、后退/前进按钮、书签菜单等等，也就是除了显示所请求页面的主窗口之外的其他所有部分。<BR>2、浏览器引擎——用于查询和操作呈现（rendering）引擎的接口。<BR>3、呈现引擎——负责显示请求的内容，例如请求的内容是HTML，它就负责解析HTML和CSS并将解析后的内容显示到屏幕上。<BR>4、网络模块——用户完成网络调用，如HTTP请求。具有平台中立的接口和针对不同平台的底层实现。<BR>5、UI后端——用于绘制基本的组合选择框及对话框之类的基本部件。具有不特定于某个平台的界面样式，在底层使用的是操作系统的用户界面方法。<BR>6、JavaScript解释器——用户解释和执行JavaScript代码。<BR>7、数据存储模块——属于持久层；浏览器需要在硬盘中保存各种数据，如Cookie。HTML5还为客户端存储定义了新的技术。</P>
<P><IMG alt="" src="浏览器 at AZI.files/layers.png"><BR>图1 浏览器的主要组件</P>
<P>需要特别指出的是，Chrome会为每个新建的标签页创建一个新的呈现引擎的实例，并且每个标签页也运行在独立的进程当中，这一点与其他浏览器不一样。<BR>对构成浏览器的这些组件，我们会逐一详细讨论。</P>
<H4>组件之间的通信</H4>
<P>Firefox和Chroem都具有联系各个组件的组件。后面也将讨论这些组件。</P>
<H2>呈现引擎</H2>
<P>呈现引擎主要负责……呈现，也就是把请求的内容显示到浏览器屏幕上。</P>
<P>默认情况下，呈现引擎可以显示HTML和XML文档以及图像。而借助插件（一种浏览器扩展）它还可以显示其他类型的内容，比如使用PDF阅读器插件可以显示PDF。后面我们还会专门讨论插件和扩展，但这里我们只讨论呈现引擎的主要用途——显示使用CSS格式化之后的HTML及图像。</P>
<H4>呈现引擎</H4>
<P>前面提到的浏览器（Firefox、Chrome和Safari）是构建在两个呈现引擎之上的。Firefox使用Gecko——Mozilla自己开发的一个呈现引擎；Safari和Chrome都使用Webkit。<BR>Webkit是一个开源的呈现引擎，最早是为Linux平台开发的，后来由苹果公司移植到Mac和Windows平台。有关内容请参考<A 
href="http://webkit.org./">http://webkit.org./</A></P>
<H4>主流程</H4>
<P>呈现引擎首先通过网络层取得被请求文档的内容。通常是以8K分块的方式完成。</P>
<P>取得内容之后，呈现引擎的基本工作流如下图所示：</P>
<P><IMG alt="" src="浏览器 at AZI.files/flow.png"><BR>图2 呈现引擎的基本工作流</P>
<P>呈现引擎会开始解析HTML文档，并将HTML标签转换成“内容树”中的<A 
href="http://www.cn-cuckoo.com/2011/02/18/how-broswers-work-2257.html#dom">DOM</A>节点。然后，它开始解析样式数据，包括外部CSS文件和style元素中的样式。解析后的样式信息，再加上HTML中的视觉指令，将被用于创建另一个树——<A 
href="http://www.cn-cuckoo.com/2011/02/18/render_tree">呈现器树</A>。</P>
<P>呈现器树中包含着各种矩形，每个矩形都有颜色和大小等属性。这些矩形都按照显示在屏幕上的顺序排列好了。</P>
<P>在构建完呈现器树之后，呈现引擎要完成一个“<A 
href="http://www.cn-cuckoo.com/2011/02/18/layout">布局</A>”过程。在这个过程中，它会精确地确定每个节点在屏幕上出现时的坐标。紧接着的一个阶段就是<A 
href="http://www.cn-cuckoo.com/2011/02/18/painting">绘制</A>——遍历呈现器树，并使用UI后端层将所有节点逐个绘制出来。</P>
<P>上述过程是逐步完成的，认识到这一点很重要。为了获得更好的用户体验，呈现引擎会尽可能早地将内容呈示到屏幕上。换句话说，它不会等到把所有HTML标签都解析完毕之后再去构建和布局呈现器树，而是解析完一部分内容，就显示一部分内容；与此同时，剩余内容可能还在通过网络不断下载的过程中。</P>
<H6>主流程示例</H6>
<P><IMG alt="" src="浏览器 at AZI.files/webkitflow.png"><BR>图3　Webkit的主流程</P>
<P><IMG alt="" 
src="浏览器 at AZI.files/image008.jpg"><BR>图4　Mozilla的Gecko呈现引擎的主流程</P>
<P>从图3和图4可以看出，Webkit和Gecko使用的术语稍有不同，但整个流程基本上是相同的。</P>
<P>Gecko把可见的格式化元素的树叫做“框架树”（Frame tree），每个元素都是一个框架。而Webkit使用的则是“呈现器树”（Render 
tree），这个树由“呈现器对象”构成。Webkit把排列元素叫做“布局”，而Gecko则称该过程为“重排”（Reflow）。同样，“附加”（Attachment）则是Webkit对连接DOM节点与样式信息以创建呈现器树的称呼。Gecko还有一个与语义无关的小差别，它在HTML与DOM树之间加了一层，叫做“内容渗入”（Content 
Sink），相当于一个制造DOM元素的工厂。下面我们就来解释流程中的每个阶段。</P>
<H6>基本解析</H6>
<P>由于解析是呈现引擎的一项非常重要的工作，因此我们会讨论得比较深入一些。首先来简单地介绍一下解析。</P>
<P>所谓的解析文档，就是把文档转换成具有某种意义的结构，以便代码能够被理解和使用。解析之后的结果通常是一个节点树，与文档的结构对应。这个节点树叫做解析树或语法树。</P>
<P>举个例子，解析表达式“2+3-1”会返回下面这个树：</P>
<P><IMG alt=""><BR>图5 算术表达式的节点树</P>
<H6>文法</H6>
<P>解析是依据文档所遵循的语法规则进行的，取决于编写文档的语言和格式。每一个要解析的格式都必须具有由词汇表和语法规则构成的文法。这种文法称为<A 
href="http://www.cn-cuckoo.com/2011/02/18/how-broswers-work-2257.html#context_free_grammer">上下文无关的文法</A>。人类语言不具备上下文无关的文法，因此无法使用通常的解析技术来解析。</P>
<H6>解析器——加上词法分析器</H6>
<P>解析可以分为两个步骤：词法分析（lexical analysis）和语法分析（syntax analysis）。</P>
<P>词法分析指的是把输入分解成符号。符号来自语言的词汇表——基本有效单元的集合。对人类语言来说，符号就相当于我们字典中的那些单词。</P>
<P>语法分析就是使用语言的语法规则进行分析。</P>
<P>解析器通常把这两项工作交给两个组件来完成：词法分析器（有时也叫分词器）负责把输入分解成符号，而解析器则负责依据语言的语法规则来分析文档结构，然后构建起解析树。词法分析器知道如何剥离空格、换行等无关字符。</P>
<P><IMG alt="" src="浏览器 at AZI.files/image011.png"><BR>图6 从源文档到解析树</P>
<P>解析过程是迭代进行的。解析器通常会要求词法分析器给出一个新的符号，然后使用该符号去匹配某种语法规则。如果匹配成功，则将与该符号对应的节点添加到解析树中，然后继续要求词法分析器再提供另一个符号。</P>
<P>如果匹配不成功，解析器会在内部保存当前符号，然后继续从词法分析器那里获取符号，直到所有内部保存的符号能够匹配一项语法规则为止。如果最终都没有找到匹配的规则，解析器就会抛出异常。这就意味着文档无效，或者说包含语法错误。</P>
<P>&nbsp;</P></DIV>
<DIV class="meta group">
<DIV class=signature>
<P>Written by admin <SPAN class=edit></SPAN></P>
<P>三月 26th, 2011 at 5:49 上午</P></DIV>
<DIV class=tags>
<P>Posted in <A title="查看 浏览器 的全部文章" href="http://173.234.53.177/?cat=8" 
rel=category>浏览器</A></P></DIV></DIV>
<H2 id=post-89><A href="http://173.234.53.177/?p=89" 
rel=bookmark>WebKit内核源代码分析（二）</A></H2>
<P class=comments><A href="http://173.234.53.177/?p=89#comments">without 
comments</A></P>
<DIV class=main>
<P>摘要：本系列通过分析WebKit的源代码，试图分析WebKit的内核设计架构，模块之间的关系，分析的时候以Qt的移植为参考，涉及移植的东西不多，主要还是以内核为主。FrameLoader类负责一个Frame的加载，在Frame的流程中起到非常重要的重要，同很多组件都有交互，本文将分析FrameLoader类的代码。</P>
<H2>1.&nbsp;概述</H2>
<P>顾名思义，FrameLoader是一个Frame的loader，它的作用就是为客户提供一个下载一个Frame的一系列接口。这里的客户指的是类的客户，比如Frame类,间接客户是上层应用，比如qwebframe。<BR>从它的定义看，最容易想到的是一个load接口，用来将一个frame 
load下来。任何一个页面至少都需要一个mainframe，因此一个页面的下载一般就是从load一个mainframe开始。<BR>在load 
frame的过程中，通过FrameLoaderClient接口将load过程的不同阶段告知客户。<BR>FrameLoader通过setDocumentLoader相当于把load的工作委托给了DocumentLoader类。<BR>FrameLoader同DocumentLoader是has-a的关系。一般在load的时候创建DocumentLoader。Frame调用DocumentLoader的startLoadingMainResource开始load 
frame。<STRONG> </STRONG></P>
<H2>2.&nbsp;类关系</H2>
<P>&nbsp;</P>
<P>1）Frame和FrameLoader是contain-a的关系，在Frame的构造函数中调用FrameLoader的构造函数，调用时传入参数Frame指针和FrameLoaderClient指针。<BR>2）Frame有可能有子Frame，所以维护SubFrameLoader对象m_subframeLoader来管理子Frame的load。Frame可以对应xml 
document，也可对应html 
document，等等。跟Document相关的子resource的load不在FrameLoader的职责范围内。<BR>3）包含一个DocumentWriter类对象m_writer，当Frame的数据load 
finish的时候，将数据传给DocumentWriter类，进行下一步的处理（比如解码）<BR>4）FrameLoader维护了三个DocumentLoader对象，分别对应于不同的阶段，m_policyDocumentLoader对应于收到用户load调用，进行policy 
check阶段，m_provisionalDocumentLoader对应于policy 
check通过以后，Frame数据还没有到来之前，它会负责startLoadingMainResource的调用。m_documentLoader则是Frame第一个数据到来以后使用的DocumentLoader，这个时候，前一个主Frame的DocumentLoader已经不能再用(user 
agent开始白屏，刷掉前一个页面的显示)。<BR>5）包含一个HistoryController对象，用于操作历史记录相关的接口，保存或者恢复Document和View相关的状态，维护前进后退队列，以实现前进后退功能，前进后退本质上是同Page对象关联的，FrameLoader通过HistoryController操作m_backFowardController对象<BR>6）包含一个ResourceLoadNotifier对象，主要用于同ResourceLoader及FrameLoaderClient打交道，可以理解为ResourceLoader有事件变化或者发生的时候，通知FrameLoader的一个手段<BR>7）包含一个SubframeLoader对象，当FrameLoader下载的Document有子帧需要请求的时候（比如HTMLDocument中解析到iframe&nbsp;元素），用来处理子帧请求<BR>8）将FrameLoader的状态封装到FrameLoaderStateMachine中，这个状态同FrameState不同，FrameState倾向于判断Frame涉及的Document的下载状态，是出于发起状态（Provisional），还是出于已经收到响应但不全（CommittedPage）,还是响应收全的状态，倾向于同http相关。而FramLoaderStateMachine倾向于同DocumentLoader相关，用来描述FrameLoader处理DocumentLoader的节点，是处于已经创建，还是显示的状态。<BR>9）PolicyChecker主要用来对FrameLoader进行一些校验。包括三种校验：NewWindow,Navigation和Content。NewWindow对应于浏览器需要新开一个tab页或窗口的时候，Navigation对应于一个页面请求发起的时候，Content校验对应于收到数据以后（判断Mime 
type等），PolicyChecker通过提供对应的接口，由FrameLoaderClient来对这些请求进行校验，以确定是否允许继续，或者需要其它的动作。</P>
<P>&nbsp;</P>
<H2>3.&nbsp;&nbsp;&nbsp;主要接口</H2>
<H3>Frame::init</H3>
<P>功能：FrameLoader的初始化</P>
<P>函数调用系列<BR>àQWebFrame::QWebFrame(QwebPage* parent,QWebFrameData 
*frameData)<BR>àQWebFramePrivate::init(QWebFrame* qwebframe,QWebFrameData* 
frameData)<BR>àFrame::init()<BR>àFrameLoader::init()</P>
<P>说明：主要做一些自身的初始化工作，比如初始化状态机，Sandbox Flags，创建DocumentLoader被设置为Policy 
DocumentLoader和Provisional 
DocumentLoader，调用DocumentLoader和documentWriter等的接口进行初始化操作</P>
<H3>FrameLoader::commitProvisionalLoad</H3>
<P>功能：提交Provisional阶段下载的数据</P>
<P>函数调用系列：<BR>àDocumentLoader::finishLoading<BR>àDocumentLoader::commitIfReady<BR>àFrameLoader::commitProvisionalLoad</P>
<P>或者<BR>àResourceLoader::didReceiveData<BR>àMainResourceLoader::addData<BR>àDocumentLoader::receiveData<BR>àDocumentLoader::commitLoad<BR>àDocumentLoader::commitIfReady<BR>àDocumentLoader::commitProvisionalLoad</P>
<P>说明：这个接口主要的操作是将Provisional 
DocumentLoader设置成DocumentLoader，因为已经收到数据，所以FrameState也会跃迁到FrameStateCommittedPage。还有历史记录，PageCache相关的操作。另外，这个接口会间接调用FrameLoaderClientQt::transitionToCommittedForNewPage，通过Frame::createView创建出FrameView来。</P>
<H3>Frame::finishedLoading</H3>
<P>功能：frame请求网络加载完成的时候调用此接口</P>
<P>函数调用系列<BR>àResourceLoader::didFinishLoading<BR>àMainResourceLoader::didFinishLoading<BR>àFrameLoader::finishedLoading<BR>àFrameLoader::init()</P>
<P>说明：检查是否有网络错误，告诉DocumentLoader和DocumentWriter下载完成，以便进行后续操作（提交数据，解析）。</P>
<H3>FrameLoader::finishedParsing</H3>
<P>功能：解析完成调用此接口</P>
<P>函数调用系列<BR>àDocumentWritter::end<BR>à….<BR>àDocument::finishParsing<BR>à….<BR>àDocument::finishedParsing<BR>àFrameLoader::finishedParsing</P>
<H3>FrameLoader::load(const ResourceRequest&amp; request,bool lockHistory)</H3>
<P>功能：加载一个frame请求，Frame请求相关的数据，封装成ResourceRequest传入。</P>
<P>函数调用系列：一般由应用触发调用</P>
<P>说明：这个接口调用FrameLoaderClientQt::createDocumentLoader创建出DocumentLoader，并以此DocumentLoader为Policy 
Document Loader，进入Policy check流程。</P>
<P>&nbsp;</P></DIV>
<DIV class="meta group">
<DIV class=signature>
<P>Written by admin <SPAN class=edit></SPAN></P>
<P>三月 26th, 2011 at 5:48 上午</P></DIV>
<DIV class=tags>
<P>Posted in <A title="查看 浏览器 的全部文章" href="http://173.234.53.177/?cat=8" 
rel=category>浏览器</A></P></DIV></DIV>
<H2 id=post-87><A href="http://173.234.53.177/?p=87" 
rel=bookmark>WebKit内核源码分析（一）</A></H2>
<P class=comments><A href="http://173.234.53.177/?p=87#comments">without 
comments</A></P>
<DIV class=main>
<P>摘要：本系列通过分析WebKit的源代码，试图分析WebKit的内核设计架构，模块之间的关系，分析的时候以Qt的移植为参考，涉及移植的东西不多，主要还是以内核为主。在分析内核的时候，Frame是首当其冲的一个类，本文将分析Frame类的代码。</P>
<H2>1.&nbsp;&nbsp;&nbsp;&nbsp;描述</H2>
<P>Frame类是WebCore内核同应用之间联系的一个重要的类。它有点像设计模式中的Façade，将内核的各个不同的零配件组装在了一起，但又不是Façade，因为用户很多时候还是要直接去操作里面的组件。除了设计上的考虑，Frame还有语法上的意义，它对应于Page里面的帧。</P>
<H2>2.&nbsp;&nbsp;&nbsp;&nbsp;类结构</H2>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>1）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FrameTree对象用来协助管理父帧和子帧的关系，常见的比如main 
frame之中有iframe元素，就会调用FrameLoaderClientQt::createFrame来产生子帧，产生的子帧会通过appendChild添加到主帧的树状结构中。Frame通过FrameTree对象，可以方便地访问它的父帧，子帧，兄弟帧。</P>
<P>2）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;维护FrameLoader对象用来完成frame的加载，FrameLoader是一个非常重要的类，后续进行进一步的分析。</P>
<P>3）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;维护NavigationScheduler对象用来管理页面跳转调度（比如重定向，meta 
refresh等）。</P>
<P>4）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOMWindow用来管理同DOM相关的事件、属性和消息。</P>
<P>5）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FrameViwe类用于Frame的排版。</P>
<P>6）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Frame文档解析后，对每一个tag或者attr，会有对应的dom节点关联，Document类用来管理这些dom节点。不同的文档类型继承出不同的子类，比如HTML文档对应子类HTMLDocument,XML文档对应于XMLDocument。</P>
<P>7）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SciptController对象，脚本控制器，用来管理脚本的执行和操作。</P>
<P>8）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Editor对象用来处理页面的编辑相关的操作，比如拷贝，粘贴，输入等，Editor对象，它同Page类的EditorClient对象紧密合作。和EditorClient的关系就如同Page同Frame的关系。</P>
<P>9）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SelectionController用来管理Frame中的选取操作。</P>
<P>10）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AnimationControlle,动画控制，控制动画的播放，暂停，继续（同HTML 
video标签是否有关系？）</P>
<P>11）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EventHandler，事件处理对象，这里的对象主要是同上层应用也就是用户参与的事件，比如鼠标事件，按键事件（快捷键等），滚动事件，resize事件等。这是一个浏览器外壳经常需要打交道的类。</P>
<H3>3.&nbsp;&nbsp;&nbsp;&nbsp;主要接口</H3>
<H3>3.1&nbsp;&nbsp;&nbsp;Create</H3>
<P>static PassRefPtr&lt;Frame&gt; 
create(Page*,HTMLFrameOwnerElement*,FrameLoaderClient*)<BR>描述：&nbsp;调用Frame构造函数，创建出Frame对象。有两个地方会创建Frame对象，一是要加载一个新的页面请求，这个时候会创建main 
frame，一是在加载子帧的时候，通过FrameLoaderClientQt的createFrame接口，创建子帧对应的Frame对象，在第一种情况中，HTMLFrameOwnerElement参数为NULL，第二种情况传子帧的父元素。在一个tab页内，main 
frame会重用。</P>
<P>调用系列：</P>
<P>àQwebPage::setView</P>
<P>àQwebPage::setViewportSize</P>
<P>àQwebPage::mainFrame</P>
<P>àQwebPagePrivate::createMainFrame</P>
<P>àQwebFrameData::QwebFrameData</P>
<P>àFrame::create<BR>àFrameLoader::finishedLoading<BR>à……</P>
<P>àHTMLDocumentParser::append</P>
<P>à……</P>
<P>àHTMLTreeBuilder::processToken</P>
<P>à……</P>
<P>àHTMLElementBase::openURL</P>
<P>àSubFrameLoader::requestFrame</P>
<P>à……</P>
<P>àFrameLoaderClientQt::creatFrame</P>
<P>àQwebFrameData::QwebFrameData</P>
<P>àFrame::create</P>
<H3>3.2&nbsp;&nbsp;createView</H3>
<P>void createView(const IntSize&amp;, const Color&amp;, bool, const 
IntSize&amp;, bool,</P>
<P>ScrollbarMode = ScrollbarAuto, bool horizontalLock = false,</P>
<P>ScrollbarMode = ScrollbarAuto, bool verticalLock = false)</P>
<P>描述：创建出FrameView对象，以用于之后的排版。应用调用这个函数的时候需要传入同排版有关的一些信息，如初始视窗大小，背景色，滚动条模式等。创建出FrameView以后，即调用Frame::setView设置成当前的FrameView。<BR>函数调用系列：<BR>àFrameLoader::commitProvisionalLoad</P>
<P>àFrameLoader::transitionToCommitted</P>
<P>àFrameLoaderClientQt::transitionToCommittedForNewPage</P>
<P>àFrame::createView</P>
<H3>3.3&nbsp;&nbsp;setDocument</H3>
<P>void setDocument(PassRefPtr&lt;Document&gt;)</P>
<P>描述：设置同Frame关联的Document对象(一般是DocumentWriter创建的)。</P>
<P>函数调用系列：</P>
<P>àQWebFrame::QwebFrame</P>
<P>àQwebFramePrivate::init</P>
<P>àFrame::init</P>
<P>àFrameLoader::init</P>
<P>àDocumentWriter：：begin</P>
<P>àFrame::setDocument<BR>àDocumentLoader::receivedData<BR>àDocumentLoader::commitLoad</P>
<P>àFrameLoaderClientQt::committedLoad</P>
<P>àDocumentLoader::commitData</P>
<P>àDocumentWriter::setEncoding</P>
<P>àDocumentWriter::willSetEncoding</P>
<P>àFrameLoader::receivedFirstData</P>
<P>àDocumentWriter::begin</P>
<P>àFrameLoader::clear</P>
<P>àFrame::setDocument</P>
<H3>3.4&nbsp;&nbsp;init</H3>
<P>void Frame::init</P>
<P>描述：Frame对象初始化，会调用FrameLoader::init初始化FrameLoader对象。</P>
<P>调用系列：<BR>àQWebFrame::QWebFrame</P>
<P>àQwebFramePrivate::init</P>
<P>àFrame::init</P>
<H3>3.5&nbsp;&nbsp;setPageAndTextZoomFactors</H3>
<P>void setPageAndTextZoomFactors(float pageZoomFactor, float 
textZoomFactor)</P>
<P>描述：设置页面放大因子和文字放大因子。在网页缩放或者改变网页字体大小的时候调用。</P>
<P>&nbsp;</P></DIV>
<DIV class="meta group">
<DIV class=signature>
<P>Written by admin <SPAN class=edit></SPAN></P>
<P>三月 26th, 2011 at 5:47 上午</P></DIV>
<DIV class=tags>
<P>Posted in <A title="查看 浏览器 的全部文章" href="http://173.234.53.177/?cat=8" 
rel=category>浏览器</A></P></DIV></DIV>
<H2 id=post-85><A href="http://173.234.53.177/?p=85" 
rel=bookmark>浏览器的内核介绍和对比</A></H2>
<P class=comments><A href="http://173.234.53.177/?p=85#comments">with one 
comment</A></P>
<DIV class=main>
<P>要搞清楚浏览器内核是什么，首先应该先搞清楚浏览器的构成。简单来说浏览器可以分为两部分，shell+内核。其中shell的种类相对比较多，内核则比较少。Shell是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。内核才是浏览器的核心。内核是基于标记语言显示内容的程序或模块。也有一些浏览器并不区分外壳和内核。从Mozilla将Gecko独立出来后，才有了外壳和内核的明确划分。目前主流的浏览器有IE6、<A 
href="http://www.iefans.net/">IE8</A>、Mozilla、FireFox、Opera、Safari、Chrome、Netscape等。</P>
<P>&nbsp;</P>
<P><STRONG>什么是浏览器内核</STRONG></P>
<P>浏览器内核又可以分成两部分：渲染引擎(layout engineer或者Rendering 
Engine)和JS引擎。它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。（参见维基百科）JS引擎则是解析Javascript语言，执行javascript语言来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了一个ACID来测试引擎的兼容性和性能。内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有10多种，但是常见的浏览器内核可以分这四种：Trident、Gecko、Presto、Webkit。</P>
<P>Trident又称MSHTML，是微软开发的渲染引擎（包含了Javascript引擎JScript），他已经深入了Windows操作系统的骨髓，例如Windows 
Media Play，Windows Explorer，Outlook 
Express等都使用了。目前很多浏览器都使用这个引擎，例如IE，Maxthon(最新版已经不使用)等。</P>
<P>Gecko是C++开发的，Open Source的渲染引擎，包括了SpiderMonkey(Rhino)。主要的使用者有Firefox。</P>
<P>Webkit是苹果公司基于KHTML开发的。他包括Webcore和JavaScriptCore（SquirrelFish,V8）两个引擎。主要的使用者有Safari，Chrome。</P>
<P>Presto由Opera Software公司开始的，用于Opera的渲染引擎。Macromedia Dreamweaver 
（MX版本及以上）和Adobe Creative Suite 2也使用了Presto的内核。</P>
<P><STRONG>主流浏览器所使用的内核分类</STRONG></P>
<P>Trident内核：IE,MaxThon,TT,The 
World,360,搜狗浏览器等<BR>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等<BR>Presto内核：Opera7及以上<BR>Webkit内核：Safari,Chrome等</P>
<P>&nbsp;</P>
<TABLE cellPadding=0 border=1>
  <TBODY>
  <TR>
    <TD><STRONG>Engine</STRONG><STRONG> </STRONG><STRONG></STRONG></TD>
    <TD><STRONG>Creator</STRONG><STRONG> </STRONG><STRONG></STRONG></TD>
    <TD width="25%"><STRONG>Software license</STRONG><STRONG> 
      </STRONG><STRONG></STRONG></TD>
    <TD width="29%"><STRONG>Leading application</STRONG><STRONG> 
      </STRONG><STRONG></STRONG></TD></TR>
  <TR>
    <TD><STRONG>Gecko</STRONG></TD>
    <TD><STRONG>Netscape</STRONG>/<STRONG>Mozilla Foundation</STRONG></TD>
    <TD width="25%"><STRONG>MPL</STRONG>/<STRONG>GNU GPL</STRONG>/<STRONG>GNU 
      LGPL</STRONG> tri-license</TD>
    <TD width="29%"><STRONG>Mozilla Firefox</STRONG></TD></TR>
  <TR>
    <TD><STRONG>KHTML</STRONG></TD>
    <TD><STRONG>KDE</STRONG></TD>
    <TD width="25%"><STRONG>GNU LGPL</STRONG></TD>
    <TD width="29%"><STRONG>Konqueror</STRONG></TD></TR>
  <TR>
    <TD><STRONG>Presto</STRONG></TD>
    <TD><STRONG>Opera Software</STRONG></TD>
    <TD width="25%"><STRONG>Proprietary</STRONG></TD>
    <TD width="29%"><STRONG>Opera</STRONG></TD></TR>
  <TR>
    <TD><STRONG>Tasman</STRONG></TD>
    <TD><STRONG>Microsoft</STRONG></TD>
    <TD width="25%"><STRONG>Proprietary</STRONG></TD>
    <TD width="29%"><STRONG>Microsoft Entourage</STRONG></TD></TR>
  <TR>
    <TD><STRONG>Trident</STRONG></TD>
    <TD><STRONG>Microsoft</STRONG></TD>
    <TD width="25%"><STRONG>Proprietary</STRONG></TD>
    <TD width="29%"><STRONG>Internet Explorer</STRONG></TD></TR>
  <TR>
    <TD><STRONG>WebKit</STRONG><STRONG> (Based on KHTML)</STRONG></TD>
    <TD><STRONG>WebKit Foundation</STRONG></TD>
    <TD width="25%"><STRONG>GNU 
    LGPL</STRONG>,&nbsp;<STRONG>BSD-style</STRONG></TD>
    <TD width="29%"><STRONG>Safari</STRONG>,&nbsp;<STRONG>Google 
      Chrome</STRONG></TD></TR></TBODY></TABLE>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><STRONG>JS引擎</STRONG></P>
<P>JavaScript最初由<STRONG>网景公司</STRONG>的Brendan 
Eich设计，是一种动态、弱类型、基于原型的语言，内置支持类。以它为基础，制定了<STRONG>ECMAScript</STRONG>标准。他的起源并不是如《Javascript高级程序设计》书中所述，是Brendan 
Eich自主发明的。（参考aimingoo的考证文章）JavaScript在浏览器的实现中还必须含有DOM和BOM。Web浏览器一般使用公共API来创建主机对象来负责将DOM对象反射进JavaScript。</P>
<P>&nbsp;</P>
<TABLE cellSpacing=0 cellPadding=0 border=1>
  <TBODY>
  <TR>
    <TD width=150 colSpan=2></TD>
    <TD width=58><STRONG>Trident</STRONG></TD>
    <TD width=104><STRONG>Gecko</STRONG></TD>
    <TD width=104><STRONG>WebKit</STRONG></TD>
    <TD width=47><STRONG>KHTML</STRONG></TD>
    <TD width=113><STRONG>Presto</STRONG></TD></TR>
  <TR>
    <TD width=150 colSpan=2><STRONG>Name of ECMAScript Engine</STRONG></TD>
    <TD width=58><STRONG>JScript</STRONG></TD>
    <TD width=104><STRONG>Spidermonkey</STRONG></TD>
    <TD width=104><STRONG>JavaScriptCore</STRONG></TD>
    <TD width=47><STRONG>KJS</STRONG></TD>
    <TD width=113><STRONG>linear b/futhark</STRONG></TD></TR>
  <TR>
    <TD width=69 rowSpan=4><STRONG>ECMAScript Version</STRONG></TD>
    <TD width=82>Edition 3</TD>
    <TD width=58>Yes</TD>
    <TD width=104>0.6</TD>
    <TD width=104>Yes</TD>
    <TD width=47>Yes</TD>
    <TD width=113>7.0</TD></TR>
  <TR>
    <TD width=82>JavaScript 1.5 extensions</TD>
    <TD width=58>No</TD>
    <TD width=104>0.6</TD>
    <TD width=104>Yes</TD>
    <TD width=47>Yes</TD>
    <TD width=113>7.0</TD></TR>
  <TR>
    <TD width=82>JavaScript 1.7 extensions</TD>
    <TD width=58>No</TD>
    <TD width=104>1.8.1</TD>
    <TD width=104>No</TD>
    <TD width=47>No</TD>
    <TD width=113>No</TD></TR>
  <TR>
    <TD width=82>JavaScript 1.8 extensions</TD>
    <TD width=58>No</TD>
    <TD width=104>1.9</TD>
    <TD width=104>No</TD>
    <TD width=47>No</TD>
    <TD width=113>No</TD></TR></TBODY></TABLE>
<P>&nbsp;</P>
<P><STRONG>浏览器内核实现原理</STRONG></P>
<P>渲染流程如下所示：</P>
<P><IMG height=200 alt=渲染引擎运作流程 src="浏览器 at AZI.files/df6a_c.jpg" width=514></P>
<P>Mozilla架构设计：界面和实现分离。采用标记语言，JavaScript，C++来开发。JSEngine就是指SpideMonkey，Layout就是指Gecko。Mozilla的一个关键部分是XPCOM和NSPR。</P>
<P><IMG height=352 alt=Mozilla架构设计 src="浏览器 at AZI.files/4077_b.jpg" 
width=492></P>
<P>Webkit的处理流程：</P>
<P><IMG height=412 alt=Webkit的处理流程 src="浏览器 at AZI.files/419d_a.jpg" 
width=558><BR><STRONG>浏览器内核的优缺点</STRONG></P>
<P>Trident：这种浏览器内核是<A 
href="http://www.iefans.net/">IE浏览器</A>用的内核，因为在早期IE占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好，甚至在2005年，与网页标准制定组织(W3C理事会)所制定的标准发生了脱节，同时 
Trident 内核本身的BUG比较多，对一些符合W3C标准的网页代码支持不是很好，这在早期的IE版本中比较明显，比如IE5.5以前(包括IE5.5)，其实<A 
href="http://www.iefans.net/ie6-liulanqi-xiazai/">IE6</A>对W3C标准的支持也不是很好，而我们现在很多人都在使用IE6，事实上它也属于一个比较早的版本。</P>
<P>但是由于IE的高市场占有率，微软也很长时间没有更新Trident内核，这导致了二个结果<BR>1，Trident内核和W3C标准脱节。<BR>2，Trident内核的大量Bug等安全问题没有得到解决，加上一些专家学者公开自己认为IE浏览器不安全的观点，使很多用户开始转向其他浏览器，FF,Opera就是这时期兴起的。<BR>Gecko：这是Firefox 
和 Flock 
所采用内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。<BR>Presto：Opera 
采用的是 
Presto内核，Presto内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理JS脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</P>
<P>Webkit：Webkit 是 Safari 采用的内核，不过 Safari 
是苹果系统下的浏览器(虽然也有windows版，但是比较少)，所以只简单介绍一下这个内核的优点和缺点，优点就是网页浏览速度较快，虽然不及 Presto 
但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。</P>
<P>&nbsp;</P></DIV>
<DIV class="meta group">
<DIV class=signature>
<P>Written by admin <SPAN class=edit></SPAN></P>
<P>三月 26th, 2011 at 5:45 上午</P></DIV>
<DIV class=tags>
<P>Posted in <A title="查看 浏览器 的全部文章" href="http://173.234.53.177/?cat=8" 
rel=category>浏览器</A></P></DIV></DIV>
<H2 id=post-83><A href="http://173.234.53.177/?p=83" 
rel=bookmark>浏览器背景知识</A></H2>
<P class=comments><A href="http://173.234.53.177/?p=83#comments">without 
comments</A></P>
<DIV class=main>
<H3>1.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网络接入</H3>
<P>浏览器是用来上网的，这个很好理解，除了离线浏览，大部分的行为就是用来跟各种服务器做交互，而交互的第一个前提就是网络接入。一个简单的例子就是PC通过modem拨号上网，当你拨号成功以后，你就会获得一个ip地址，可以同网络上的其它ip进行通讯，这就是接入了，当你不上网的时候，你会挂断。</P>
<P>因为用户需要接入，就诞生了ISP（Internet Service 
Provider），来为用户提供互联网接入服务，在上面的例子中，拨号我们可能拨163，或者263，这就是一个ISP。大部分用户通过以太网网卡和网线和PC连接在一起，可能用的是电信、网通、铁通，他们都是ISP。</P>
<P>中国移动通过GPRS和EDGE为用户提供互联网接入，他也是ISP。</P>
<P>在大陆，大的ISP有：中国电信，中国网通、中国铁通、中国移动、中国联通。</P>
<P>在手机等无线终端里面，我们更多的听到的是“承载方式”这个词，主要是根据终端接入ISP的网络方式来区分的，常见的承载方式有GSM，GPRS、EDGE、CDMA,WIFI等等，不通的承载方式网络速度的差别比较大。</P>
<H3>1.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据传输</H3>
<P>接入互联网仅仅相当于我们的物理链路打通了，我们需要找到我们要通讯的对象，以及要确保在不可靠的物理链路上实现可靠地传输，需要流量控制来提高我们的链路传输性能，这就需要IP，TCP，UDP等协议来协助我们。</P>
<P>简单地说，IP是互联网协议，主要负责的是寻址和选路，同时适应我们的承载，做一些简单的分片工作。TCP协议则帮助我们实现的可靠传输、流量控制和多路复用等功能。UDP则主要是多路复用和不可靠的数据传输。如果采用UDP，一般应用层要自己保证数据的可靠性。</P>
<P>在无线网络中，wdp+wtp用来实现同tcp类似的功能。</P>
<P>在系统级别上，比较常见的是将TCP/IP,UDP封装成套接字的接口，供浏览器内核调用。</P>
<P>因此，我们从浏览器的角度看，接触到的主要是如下几个过程：</P>
<P>1）&nbsp;&nbsp;解析dns，由于访问的时候，键入的大部分是域名，而套接字的通讯是以ip地址为标识之一的。有的系统会在本地有域名表供查询，如果查不到，再给dns 
server发送dns query数据包。有的系统，则将dns查询和套接字的连接（connect）封装在一起。</P>
<P>2）&nbsp;&nbsp;连接服务器，这就是我们经常提到的tcp的三次握手</P>
<P>3）&nbsp;&nbsp;查询套接字，如bsd socket的select，就是要检测套接字的可读，可写，关闭等消息。</P>
<P>4）&nbsp;&nbsp;发送数据</P>
<P>5）&nbsp;&nbsp;接收数据</P>
<P>6）&nbsp;&nbsp;关闭连接</P>
<H3>1.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;超文本传输协议（HTTP）</H3>
<P>HTTP协议建立了请求—响应模型，用来帮助服务器和终端之间传输超文本。一个简单的HTTP过程如下：</P>
<P>1）&nbsp;&nbsp;客户端向服务器发送一个请求</P>
<P>GET&nbsp;<A 
href="http://www.google.cn/somedata.exe">http://www.google.cn/somedata.exe</A></P>
<P>Host:&nbsp;<A href="http://www.google.cn/">http://www.google.cn/</A></P>
<P>Accept: */*</P>
<P>Cache-Control: no-cache</P>
<P>User-Agent: dillo</P>
<P>2）&nbsp;&nbsp;服务器响应以资源内容</P>
<P>HTTP/1.0200OK</P>
<P>Date:Mon,31Dec200104:25:57GMT</P>
<P>Server:Apache/1.3.14(Unix)</P>
<P>Content-type:text/html</P>
<P>Last-modified:Tue,17Apr200106:46:28GMT</P>
<P>Etag:”a030f020ac7c01:1e9f”</P>
<P>Content-length:397</P>
<P>&nbsp;</P>
<P>&lt;html&gt;……………………..&lt;/html&gt;</P>
<P>&nbsp;</P>
<P>由于是一个简单的request—response响应，所以http会话本身是没有状态的，后来为了实现有状态，提出了cookie的概念，现在cookie在网络上很经常用来携带账号相关的信息，因此cookie的使用时有一定风险的，大部分浏览器都提供禁用cookie的开关。</P>
<P>另外，为了避免同服务器之间反复的交互，减小网络负载，http还引入了cache的机制。对于像baidu首页这样的页面，是很少做改变的，因此客户端访问过一次以后，可以将它缓存下来，下次再访问，只要缓存没有过期，就可以直接从本地取，不需要再从baidu的服务器取到页面数据。</P>
<P>在无线网络中，收到带宽的限制，还经常对http的体部做内容编码，常见的编码方式就是gzip，这样客户端在受到数据以后，必须对数据进行解码。</P>
<P>http协议对浏览器的理解非常重要，有兴趣的同志建议看rfc2616。</P>
<H3>1.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据的安全传输（SSL/TLS）</H3>
<P>由于http协议是以明文传送的，因此用来传递账号相关的信息是不合适的。</P>
<P>Netscape公司设计了SSL，用来实现数据在网络上的安全传输。ietf将SSL标准化后叫TLS，两者并没有特别大的区别。</P>
<P>SSL在协议架构上的位置如下：</P>
<P>－－－－－－－－－<BR>|&nbsp;&nbsp;&nbsp;&nbsp;HTTP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<BR>－－－－－－－－－<BR>|&nbsp;&nbsp;&nbsp;&nbsp;SSL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<BR>－－－－－－－－－<BR>|&nbsp;&nbsp;&nbsp;&nbsp;TCP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<BR>－－－－－－－－－<BR>|&nbsp;&nbsp;&nbsp;&nbsp;IP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<BR>－－－－－－－－－</P>
<P>在tcp连接成功后，用户代理首先同服务器进行安全协商，也就是ssl的handshake，在握手成功后，才发起HTTP请求，所发的HTTP请求会由商定的加密算法进行加密，所以看到的不再是GET&nbsp;<A 
href="http://www.baidu.com/">http://www.baidu.com/</A> 
/HTTP1.1这样的明文，而是SSL里面的applicationdata，服务器收到请求后进行解密，将响应加密后传给用户代理，用户代理调用解密算法对ssl的applicationdata解密得到HTTP的响应，协议比较简单，关键在于加密算法上。</P>
<P>有兴趣的同志可以参阅<A 
href="http://www.ietf.org/rfc/rfc2246.txt">http://www.ietf.org/rfc/rfc2246.txt</A>，另外，绿盟的文章SSL/TLS/WTLS原理（<A 
href="http://www.nsfocus.net/index.php?act=magazine&amp;do=view&amp;mid=841">http://www.nsfocus.net/index.php?act=magazine&amp;do=view&amp;mid=841</A>）讲解非常通俗易懂，可以学习下。</P>
<H3>1.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标记语言解析</H3>
<P>html/xhtml/wml是网页常用的标记语言。也是用户代理通过HTTP获得的网页的内容，通过标记语言，网页编写者将网站的内容有效地组织在一起，并为用户提供导航。为了方便地操作网页中的个体元素以及数据，实现与浏览器、平台、语言的无关性，W3C提出了文档对象模型的概念（DOM：Document 
Object Model）。</P>
<P>一般来说，浏览器的解析工作就是解析标记语言，分析出标记语言的结构，用于后面要进行的网页排版和渲染工作中。支持DOM的浏览器还会在这个过程形成DOM树状结构。</P>
<P>另外，网页中还会嵌入图片资源，背景音，外部CSS和其他对象资源，解析过程还要将这些嵌入资源找出来，以便对嵌入资源进行HTTP请求。</P>
<H3>1.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网页排版和渲染</H3>
<P>在标记语言解析完毕以后，浏览器需要对页面的各个组件进行排版，计算他们在页面中的位置坐标和大小，然后在显示设备上将对应的组件渲染出来。网页排版和渲染是浏览器的核心技术，好的浏览器会有很好的显示效果和渲染性能。渲染的时候，会调用到平台上的图形库。比如GTK，QT之类的。浏览器的移植工作很大部分就在于图形库的移植。</P>
<H3>1.7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CSS（层叠样式表）</H3>
<P>CSS用来对页面的布局、字体、颜色、背景等进行控制，它会引起网页的重新排版，让网页看起来像一个个容器的概念。CSS让页面的内容和表现分离开来，而且能够让网站保持风格的一致性，是当前页面设计的主流。</P>
<P>一个简单的例子，可能你也遇到过，访问一个网页的时候，有时候网速比较慢，会发现网页下来以后，页面排版乱七八糟的，跟平时表现不一样，这时候，很有可能就是CSS还没有下载下来。</P>
<H3>1.8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JAVASCRIPT</H3>
<P>JAVASCIPT是一个面向对象的客户端脚本。由于能够调用客户端的CPU来做事情，所以JAVASCIPT的潜力是巨大的。他的设计初衷是让客户端自己来进行一些数据的验证，做一些交互，减少客户端同服务器的交互，现在得到了大量的运用，主流网站都会在自己的网页上嵌入javascript。当然，javascript对浏览器的性能的挑战也是巨大的，恶意的递归可能让浏览器crash。</P>
<P>Google为什么要开发chrome？就是想在服务器上提供更多的类似在线office这样的软件，即时髦的云计算，这些又是怎么做到了呢?在客户端来说，就是强大的javascript处理能力。Chrome用的是webkit的内核，最大的改进就在于Javascript 
V8引擎。Google专门请了天才拉斯巴克来写V8引擎，还允许拉斯巴克在自己的农舍上班，而不是到google的办公室。</P>
<P>在嵌入式终端中，还有wmlscript脚本，他是一个轻量级的javascript，主要用来验证用户输入，生成消息框,简单计算。同javascript不同的是，他不嵌入网页，要通过url访问，由于功能非常有限，现在已经很少得到使用。下面是javascript和wmlscript的例子：</P><PRE>&lt;html&gt;</PRE><PRE>&lt;head&gt;</PRE><PRE>&nbsp; &lt;script language="LiveScript"&gt;</PRE><PRE>&nbsp;&nbsp;&nbsp;&nbsp; function pushbutton() {</PRE><PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert("嗨! 你好");</PRE><PRE>&nbsp; }</PRE><PRE> &lt;/script&gt;</PRE><PRE>&lt;/head&gt;</PRE><PRE>&lt;body&gt;</PRE><PRE>&lt;form&gt;</PRE><PRE>&nbsp; &lt;input type="button" name="Button1" value="Push me" onclick="pushbutton()"&gt;</PRE><PRE>&nbsp; &lt;/form&gt;</PRE><PRE>&lt;/body&gt;</PRE><PRE>&lt;/html&gt;</PRE>
<P>&nbsp;</P>
<DIV>
<P>wml script例子</P>
<P>wml文件中</P>
<P>&lt;card id=”no1″ title=”Go to URL”&gt;</P>
<P>&lt;do type=”options” label=”Go”&gt;</P>
<P>&lt;go href=”check.wmls#go_url(‘W3School’)”/&gt;</P>
<P>&lt;/do&gt;</P>
<P>&lt;/card&gt;</P>
<P>check.wmls文件中，定义了go_url</P>
<P>extern function go_url(the_url)</P>
<P>{</P>
<P>if (the_url==”W3School”)</P>
<P>{</P>
<P>WMLBrowser.go(“<A 
href="http://www.w3school.com.cn/wmlscript/wap.wml">http://www.w3school.com.cn/wmlscript/wap.wml</A>“)</P>
<P>}</P>
<P>}</P></DIV>
<H3>1.9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;浏览器简单流程</H3>
<P>下面以tcp连接为例简单介绍浏览器的流程。</P>
<P>1）&nbsp;&nbsp;接入互联网，很多情况下，终端都是一直在线了，所以这部可以省略。但是像GPRS这样的承载，都是在进入浏览器的时候才打开gprs通道。</P>
<P>2）&nbsp;&nbsp;用户输入url</P>
<P>3）&nbsp;&nbsp;浏览器对url进行dns解析，由于dns解析可能涉及到网络或者文件操作，所以dns解析式异步的。</P>
<P>4）&nbsp;&nbsp;dns解析到ip地址后，浏览器调用socket去连接远端服务器（如果是使用了HTTP 
Proxy，则这个时候连接的是Proxy地址），因为是tcp连接，需要做三次握手，所以也是异步的。</P>
<P>5）&nbsp;&nbsp;浏览器在调用连接的接口后，会轮询套接字，如果套接字收到了连接成功的消息（或者，在某些套接字设计中，是可写消息），就调用套接字的发送接口来发送HTTP请求数据。</P>
<P>6）&nbsp;&nbsp;发送请求的过程也是一个异步的过程，而且非常有可能不能一次性发完，这个时候会不停地轮询套接字，检测可写消息。</P>
<P>7）&nbsp;&nbsp;发送完请求数据后，就等待响应。知道套接字有了可读消息，HTTP就去收数据，数据一般多次才能收齐。HTTP1.1通过content-length头部或者chunked机制来判断什么时候收起数据，而1.0则通过对端关闭来判断。</P>
<P>8）&nbsp;&nbsp;收齐数据后，HTTP解析响应，有选择性地对体部数据进行解码（如果存在编码），将解码后的数据传给解析模块进行解析。当然，好的浏览器，能够做到边收数据边解析。</P>
<P>9）&nbsp;&nbsp;解析标记语言，形成解析数据结构和DOM树。如果页面中含有嵌入子媒体对象（如图片，外部CSS，背景音，其它对象），则发起HTTP请求，请求对应数据。</P>
<P>10）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对网页进行排版（如果有CSS，要根据CSS规则进行排版）</P>
<P>11）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;渲染网页</P>
<P>&nbsp;</P></DIV>
<DIV class="meta group">
<DIV class=signature>
<P>Written by admin <SPAN class=edit></SPAN></P>
<P>三月 26th, 2011 at 5:44 上午</P></DIV>
<DIV class=tags>
<P>Posted in <A title="查看 浏览器 的全部文章" href="http://173.234.53.177/?cat=8" 
rel=category>浏览器</A></P></DIV></DIV>
<DIV class="navigation group">
<DIV class=alignleft></DIV>
<DIV class=alignright></DIV></DIV></DIV>
<DIV id=sidebar>
<DIV id=pages>
<H3>Pages</H3>
<UL>
  <LI class="page_item page-item-2"><A title=关于 
  href="http://173.234.53.177/?page_id=2">关于</A> </LI></UL></DIV>
<H3>Search</H3>
<P class=searchinfo>search site archives</P>
<DIV id=search>
<DIV id=search_area>
<FORM id=searchform action=/index.php method=get>
<DIV><INPUT class=searchfield id=s title="Enter keyword to search" name=s> <INPUT class=submit title="Click to search archives" type=submit value=search> 
</DIV></FORM></DIV></DIV>
<H3>Blogroll</H3>
<UL>
  <LI><A href="http://codex.wordpress.org/">Documentation</A> 
  <LI><A href="http://wordpress.org/extend/plugins/">Plugins</A> 
  <LI><A href="http://wordpress.org/extend/ideas/">Suggest Ideas</A> 
  <LI><A href="http://wordpress.org/support/">Support Forum</A> 
  <LI><A href="http://wordpress.org/extend/themes/">Themes</A> 
  <LI><A href="http://wordpress.org/news/">WordPress Blog</A> 
  <LI><A href="http://planet.wordpress.org/">WordPress Planet</A> </LI></UL>
<H3>Archives</H3>
<UL>
  <LI><A title="2011 年八月" href="http://173.234.53.177/?m=201108">2011 年八月</A> 
  <LI><A title="2011 年七月" href="http://173.234.53.177/?m=201107">2011 年七月</A> 
  <LI><A title="2011 年六月" href="http://173.234.53.177/?m=201106">2011 年六月</A> 
  <LI><A title="2011 年四月" href="http://173.234.53.177/?m=201104">2011 年四月</A> 
  <LI><A title="2011 年三月" href="http://173.234.53.177/?m=201103">2011 年三月</A> 
  </LI></UL>
<H3>Categories</H3>
<UL>
  <LI class="cat-item cat-item-5"><A title="查看 CSS样式 下的所有文章" 
  href="http://173.234.53.177/?cat=5">CSS样式</A> 
  <LI class="cat-item cat-item-7"><A title="查看 JVM指令 下的所有文章" 
  href="http://173.234.53.177/?cat=7">JVM指令</A> 
  <LI class="cat-item cat-item-4"><A title="查看 技术专家介绍 下的所有文章" 
  href="http://173.234.53.177/?cat=4">技术专家介绍</A> 
  <LI class="cat-item cat-item-3"><A title="查看 杂记 下的所有文章" 
  href="http://173.234.53.177/?cat=3">杂记</A> 
  <LI class="cat-item cat-item-8 current-cat"><A title="查看 浏览器 下的所有文章" 
  href="http://173.234.53.177/?cat=8">浏览器</A> 
  <LI class="cat-item cat-item-1"><A title="查看 解读Android 下的所有文章" 
  href="http://173.234.53.177/?cat=1">解读Android</A> </LI></UL>
<H3>Meta</H3>
<UL>
  <LI>
  <LI><A href="http://173.234.53.177/wp-login.php">登录</A> 
  <LI><A title="Syndicate this site using RSS" 
  href="feed:http://173.234.53.177/?feed=rss2">Site Feed</A> 
  <LI><A title="使用 RSS 同步站点的近期评论" 
  href="feed:http://173.234.53.177/?feed=comments-rss2">Comments Feed</A> 
  <LI><A title="back to top" href="http://173.234.53.177/?cat=8#content">Back to 
  top</A> </LI></UL></DIV></DIV>
<DIV id=footer>
<P>The Journalist template by <A href="http://lucianmarin.com/" 
rel=designer>Lucian E. Marin</A> — Built for <A 
href="http://wordpress.org/">WordPress</A></P></DIV></BODY></HTML>
