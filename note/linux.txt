1 /bin/sh ./script.sh
  以这种方式执行不需要script.sh文件具有可执行权限
2 进程间采用内存保护技术，不会因为一个应用程序的崩溃而导致整个系统的崩溃。
3 安装和登录命令：login、 shutdown、 halt、 reboot 、mount、umount 、chsh
  文件处理命令：file、 mkdir、 grep、dd、 find、 mv 、ls 、diff、 cat、 ln
  系统管理相关命令： df、 top、 free、 quota 、at、 lp、 adduser、 groupadd kill、 crontab、   tar、 unzip、 gunzip 、last
  网络操作命令：ifconfig、 ip 、ping 、 netstat 、telnet、 ftp、 route、 rlogin rcp 、finger   、mail 、nslookup
  系统安全相关命令： passwd 、su、 umask 、chgrp、 chmod、chown、chattr、sudo、 pswho
4 dir_color
5 编译内核
6 在 Linux 的世界中，絕大部分的設定檔都是以 ASCII 的純文字形態存在
7 vim 编辑器 操作不同
8 Linux Native（根分区和Linux Swap（数据交换区）
9 Linux应安装在硬盘分区的最后一个扩展分区
10 cp -a
11 ctr+Backspace
12 用autotools生成的makefile报错:missing separator，其实是makefile.am中missing separator
13 makefile.am中的subdirs是指要生成makefile的子目录
14 fork return nonzero value is subProcess's PID
15 /boot/grub/menu.lst下设置分辨率
   kernel: .....    vga=791
   Colors ( depth)- 640x480- 800x600- 1024x768- 1280x1024- 1600x1200|
    -------------------+---------+-----------+-----------+-------------+--------------|
   256    ( 8 bit) |   769         771          773              775           796    |
   32,768 (15 bit) |   784         787          790              793           797    |
   65,536 (16 bit) |   785         788          791              794           798    |
   16.8M (24 bit)  |   786         789          792              795           799    |
16 gcc test.c –o test `pkg-config --cflags --libs gtk+-2.0 libglade-2.0` -export-dynamic
17 apt-get install samba
   apt-get install openSSH-server
   apt-get install build-essential
   apt-get install libtool
   
   apt-get install x-window-system-core
   apt-get install libgtk2.0-dev
   apt-get install glade

18 export DISPLAY=:0.0
19 ./configure --without-libtiff --x-includes=/usr/X11R6/includes --x-            libraries=/usr/X11R6/lib
20 pkg-config --modversion gtk+-2.0
21 
22 apt-get update --fix-missing
23 
24 X resolution /etc/X11/xorg.conf depth 24
   Virtual 800 450
25/etc/resolv.conf dns
26 build-essential
27 
28 debian-based system : ubuntus
29 etc/profile export LS_OPTIONS='--color=auto'
30 Makefile.am中的subdirs 分编译的先后顺序
31 gtk只认utf8编
32 fc-list | grep -i sun查看是否已安装宋体
33 装完字体后，给所有用户权限
34 gtk-builder-convert *.glade *.xml
35 If you get "Gtk-WARNING **: Could not find signal handler..." and your handlers are          inside *.cpp file, add to their    declaration: 
   extern "C" .............. . 
   Otherwise exported names are "decorated", which is C++'s default.
36 c/c++相互调用本质上就是用extern "C"屏蔽c++编译器生成的用来区分重载函数的符号
37 autotools中的configure.in的项目名称与Makefile.am中的可执行文件名称不要冲突
38 iface eth0 inet static
   auto eht0
   
   gateway
   address
   netmask
39 find / -name file
   grep string -i -r file/dir
40 printf add \n
41 top layer Makefile.am: "export INCLUDES" will be global 
42 gbk
   1)表示繁体字和简体字
   2)只表示中文

   gb2312
   1)只能表示简体字
   2)只表示中文   
   
   Unicode：
   1)不兼容任何编码
   2)定长编码

   utf:  
   1)兼容iso8859-1
         不定长编码(1~6)

43 若LC_COLLATE为"POSIX"或"C"，则strcoll()与strcmp()作用完全相同

44在项目的起始阶段，目的平台尚未建立，因此需要做交叉编译，以生成我们所需要的bootloader（启动   引导代码）以及操作系统核心；其次，当目的平台能启动之后，由于目的平台上资源的限制，当我们     编译大型程序时，依然可能需要用到交叉编译

45 对于交叉编译器，可以自己生成
46 bootloader: 
   1)redboot
   2)U-Boot 
   3)Bootldr 

1022:
   动态库的搜索路径搜索的先后顺序是：
   1.编译目标代码时指定的动态库搜索路径；
   2.环境变量LD_LIBRARY_PATH指定的动态库搜索路径；
   3.配置文件/etc/ld.so.conf中指定的动态库搜索路径；
   4.默认的动态库搜索路径/lib；
   5.默认的动态库搜索路径/usr/lib。

1023
   1 date +%T -s 13:07:00
   2 fnPhonebook_LDFLAGS=-Wl,-rpath,/home/elon/opt/x86-usr/lib
     fnPhonebook_CFLAGS=-Wl,-rpath,/home/elon/opt/x86-usr/lib
   3 profile 是交互式、login 方式进入 bash 运行的
     bashrc 是交互式 non-login 方式进入 bash 运行的

1025
   1 long long lg=8888...88LL
<<<<<<< .mine
     lld%

1028 apt-get install gtk2.0-examples=======
     lld%

10.28 每gtk_builder_get_object一次，就实例化多一个 >>>>>>> .r271
   
10.29 debian /etc/init.d/samba restart
                         smbd

11.02 const char *home = getenv("HOME");
      
      imgdir=$(datadir)/img
      img_DATA=$(top_srcdir)/src/phonebook/img/*

11.05 aptitude

11.06 #PKG_CHECK_MODULES(GTK2, [GTK2], found=yes, found=no)
   #if test x$found = xyes ; then
   #  CFLAGS="$CFLAGS $GTK2_CFLAGS"
   #  LIBS="$LIBS $GTK2_LIBS"
   #else
   #  AC_MSG_NOTICE([Could not find GTK2 DEFINES])
   # LIBS="$LIBS `pkg-config --libs gtk+-2.0`"
   # CFLAGS="$CFLAGS `pkg-config --cflags --libs gtk+-2.0` -export-dynamic"
   #fi
	
   pc file pass args to configure.in 
   ##_ multi args

11.21 apt-get install lrzsz
      couldn't read interface file: interface wrong
         
1201 offline mode of firefox is ridiculous 
     client session is ridiculous(samba)
     net use * /del

1209 利用CIFS和NFS共享文件实际涉及到两次的文件系统转换。客户端从服务器端申请一个文件时，服务器端首先从本地读出文件（本地文件系统格式），并以          NFS/CIFS的格式封装成IP报文并发送给客户端。客户端收到IP报文以后，把文件存储与本地磁盘中（本地文件系统格式）
     
     （1）CIFS面向网络连接的共享协议，对网络传输的可靠性要求高，常使用TCP/IP；NFS是独立于传输的，可使用TCP或UDP；
     （2）NFS缺点之一，是要求client必须安装专用软件；而CIFS集成在OS 内部，无需额外添加软件；
     （3）NFS属无状态协议，而CIFS属有状态协议；NFS受故障影响小，可以自恢复交互过程，CIFS不行；从传输效率上看，CIFS优于NFS，没用太多冗余信息传送
     （4）两协议都需要文件格式转换，NFS保留了unix的文件格式特性，如所有人、组等等；CIFS则完全按照win的风格来作。
     
      NFS在文件传送或信息传送过程中依赖于RPC协议

      Sun 公司需要解决的根本问题是如何将几台 UNIX 机器连接在一起，从而构成一个无缝的分布式工作环境，而不需要重新编写 UNIX 文件系统的语义，同时也	      不用添 太多分布式文件系统特有的数据结构

      apt-get install nfs-kernel-server
      

1228 YAFFS 是基于日志的文件系统，提供磨损平衡和掉电恢复的健壮性
     YAFFS中，文件是以固定大小的数据块进行存储的

--------------------------------------------------- 2011 -----------------------------------------------------------

0108 fedora network config: /etc/sysconfig/network-scripts/ifcfg-eth0
     DEVICE=eth0HWADDR=xx:xx:xx:xx:xx:xx    //MAC地址
     BOOTPROTO=noneNETMASK=255.255.255.0       //子网掩码
     IPADDR=172.17.x.x                 //IP地址
          ONBOOT=yes
     USERCTL=no
     PEERDNS=yes
     IPV6INIT=no
     NM_CONTROLLED=yes
     GATEWAY=172.17.x.254          //默认网关
     TYPE=Ethernet
     添加DNS只要在末尾添加这句
     DNS1＝     218.85.157.99
     DNS2＝202.101.98.55
     

0109 apt-get install nfs-client
     intr -- 当服务器宕机或者无法到达时，允许中断NFS请求。 
     nfsvers=2或者nfsvers=3 -- 指定使用那个版本的NFS协议。 
     nolock -- 禁用文件锁。这个设置在连接到一个旧版本的NFS服务器时偶尔会用到。 
     noexec -- 防止执行被挂接的系统上的二进制文件。这在系统通过NFS挂接一个包含有不兼容的二进制文件     的非     linux系统时是很有用的。 
     nosuid -- 禁用"设置用户标志位"（set-user-identifier）或者"设置组标志位"（set-group-identifie		r）。	这样防止远程用户运行setuid程序获得更高权限。 
	rsize=8192和wsize=8192 -- 通过设定大的同时传输的数据块大小(bytes)，以提高NFS读写的速度。改	变这些值	时要当心，一些旧的linux内核和网卡在大的块大小不能正常工作。 
	tcp -- 指定NFS使用TCP协议mount，替换UDP。 

     apt-get smbfs

APT-RPM project is a port of Debian's APT tools to a RPM based distribution (Conectiva, Red Hat, SuSE, ALT-Linux, etc). APT is an advanced package management utility front-end which allows you to easily perform package installation, upgrading and removal.

Dependencies are automatically handled, so if you try to install a package that needs others to be installed, it will download all needed packages and install them.

0111  Alsa: An audio library (and kernel level API) for Linux

0114 typedef enum {                                                                                                     
    XML_ELEMENT_NODE=   1,                                                                                         
    XML_ATTRIBUTE_NODE=   2,                                                                                       
    XML_TEXT_NODE=    3,                                                                                           
    XML_CDATA_SECTION_NODE= 4,                                                                                     
    XML_ENTITY_REF_NODE=  5,                                                                                       
    XML_ENTITY_NODE=    6,                                                                                         
    XML_PI_NODE=    7,                                                                                             
    XML_COMMENT_NODE=   8,                                                                                         
    XML_DOCUMENT_NODE=    9,                                                                                       
    XML_DOCUMENT_TYPE_NODE= 10,                                                                                    
    XML_DOCUMENT_FRAG_NODE= 11,                                                                                    
    XML_NOTATION_NODE=    12,                                                                                      
    XML_HTML_DOCUMENT_NODE= 13,                                                                                    
    XML_DTD_NODE=   14,                                                                                            
    XML_ELEMENT_DECL=   15,                                                                                        
    XML_ATTRIBUTE_DECL=   16,                                                                                      
    XML_ENTITY_DECL=    17,                                                                                        
    XML_NAMESPACE_DECL=   18,                                                                                      
    XML_XINCLUDE_START=   19,                                                                                      
    XML_XINCLUDE_END=   20                                                                                         
    #ifdef LIBXML_DOCB_ENABLED                                                                                        
   ,XML_DOCB_DOCUMENT_NODE= 21                                                                                        
    #endif                                                                                                           
} xmlElementType;            
            
0308 ^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((\.[a-zA-Z0-9_-]{2,3}){1,2})$
    
*************************************************************************************
Start					regex    				Start
*************************************************************************************
元字符

现在你已经知道几个很有用的元字符了，如\b,.,*，还有\d.正则表达式里还有更多的元字符，比如\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\w匹配字母或数字或下划线或汉字等。
对中文/汉字的特殊处理是由.Net提供的正则表达式引擎支持的，其它环境下的具体情况请查看相关文档。
下面来看看更多的例子：
\ba\w*\b匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)。
好吧，现在我们说说正则表达式里的单词是什么意思吧：就是不少于一个的连续的\w。不错，这与学习英文时要背的成千上万个同名的东西的确关系不大 :)
\d+匹配1个或更多连续的数字。这里的+是和*类似的元字符，不同的是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。
\b\w{6}\b 匹配刚好6个字符的单词。
表1.常用的元字符
代码	说明
.	匹配除换行符以外的任意字符
\w	匹配字母或数字或下划线或汉字
\s	匹配任意的空白符
\d	匹配数字
\b	匹配单词的开始或结束
^	匹配字符串的开始
$	匹配字符串的结束正则表达式引擎通常会提供一个“测试指定的字符串是否匹配一个正则表达式”的方法，如JavaScript里的RegExp.test()方法或.NET里的Regex.IsMatch()方法。这里的匹配是指是字符串里有没有符合表达式规则的部分。如果不使用^和$的话，对于\d{5,12}而言，使用这样的方法就只能保证字符串里包含5到12连续位数字，而不是整个字符串就是5到12位数字。
元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\d{5,12}$。
这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。
因为使用了^和$，所以输入的整个字符串都要用来和\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。
和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。
字符转义

如果你想查找元字符本身的话，比如你查找.,或者*,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用\.和\*。当然，要查找\本身，你也得用\\.
例如：deerchao\.net匹配deerchao.net，C:\\Windows匹配C:\Windows。
重复

你已经看过了前面的*,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)：
表2.常用的限定符
代码/语法	说明
*	重复零次或更多次
+	重复一次或更多次
?	重复零次或一次
{n}	重复n次
{n,}	重复n次或更多次
{n,m}	重复n到m次
下面是一些使用重复的例子：
Windows\d+匹配Windows后面跟1个或更多数字
^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)
字符类

要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？
很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。
我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。
下面是一个更复杂的表达式：\(?0\d{2}[) -]?\d{8}。
“(”和“)”也是元字符，后面的分组节里会提到，所以在这里需要使用转义。
这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符\(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。
分枝条件

不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：
0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。
\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。
\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。
分组

我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。
(\d{1,3}\.){3}\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})。
IP地址中每个数字都不能大于255，大家千万不要被《24》第三季的编剧给忽悠了……
不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。
理解这个表达式的关键是理解2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。
反义

有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：
表3.常用的反义代码
代码/语法	说明
\W	匹配任意不是字母，数字，下划线，汉字的字符
\S	匹配任意不是空白符的字符
\D	匹配任意非数字的字符
\B	匹配不是单词开头或结束的位置
[^x]	匹配除了x以外的任意字符
[^aeiou]	匹配除了aeiou这几个字母以外的任意字符
例子：\S+匹配不包含空白符的字符串。
<a[^>]+>匹配用尖括号括起来的以a开头的字符串。
后向引用

使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。
呃……其实,组号分配还不像我刚说得那么简单：
分组0对应整个正则表达式
实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号
你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．
后向引用用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。难以理解？请看示例：
\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。
你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?<Word>\w+)(或者把尖括号换成'也行：(?'Word'\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k<Word>,所以上一个例子也可以写成这样：\b(?<Word>\w+)\b\s+\k<Word>\b。
使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：
表4.常用分组语法
分类	代码/语法	说明
捕获	(exp)	匹配exp,并捕获文本到自动命名的组里
(?<name>exp)	匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
(?:exp)	匹配exp,不捕获匹配的文本，也不给此分组分配组号
零宽断言	(?=exp)	匹配exp前面的位置
(?<=exp)	匹配exp后面的位置
(?!exp)	匹配后面跟的不是exp的位置
(?<!exp)	匹配前面不是exp的位置
注释	(?#comment)	这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读
我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？
零宽断言

地球人，是不是觉得这些术语名称太复杂，太难记了？我也有同感。知道有这么一种东西就行了，它叫什么，随它去吧！人若无名，便可专心练剑；物若无名，便可随意取舍……
接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：
断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。
(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I'm singing while you're dancing.时，它会匹配sing和danc。
(?<=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?<=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。
假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?<=\d)\d{3})+\b，用它对1234567890进行查找时结果是234567890。
下面这个例子同时使用了这两种断言：(?<=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。
负向零宽断言

前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词--它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：
\b\w*q[^u]\w*\b匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w*\b将会匹配下一个单词，于是\b\w*q[^u]\w*\b就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：\b\w*q(?!u)\w*\b。
零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。
同理，我们可以用(?<!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?<![a-z])\d{7}匹配前面不是小写字母的七位数字。
请详细分析表达式(?<=<(\w+)>).*(?=<\/\1>)，这个表达式最能表现零宽断言的真正用途。
一个更复杂的例子：(?<=<(\w+)>).*(?=<\/\1>)匹配不包含属性的简单HTML标签内里的内容。(?<=<(\w+)>)指定了这样的前缀：被尖括号括起来的单词(比如可能是<b>)，然后是.*(任意的字符串),最后是一个后缀(?=<\/\1>)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。
注释

小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)。
要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：
      (?<=    # 断言要匹配的文本的前缀
      <(\w+)> # 查找尖括号括起来的字母或数字(即HTML/XML标签)
      )       # 前缀结束
      .*      # 匹配任意文本
      (?=     # 断言要匹配的文本的后缀
      <\/\1>  # 查找尖括号括起来的内容：前面是一个"/"，后面是先前捕获的标签
      )       # 后缀结束
贪婪与懒惰

当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。
有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：
a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。
为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。
表5.懒惰限定符
代码/语法	说明
*?	重复任意次，但尽可能少重复
+?	重复1次或更多次，但尽可能少重复
??	重复0次或1次，但尽可能少重复
{n,m}?	重复n到m次，但尽可能少重复
{n,}?	重复n次以上，但尽可能少重复
处理选项

在C#中，你可以使用Regex(String, RegexOptions)构造函数来设置正则表达式的处理选项。如：Regex regex = new Regex(@"\ba\w{6}\b", RegexOptions.IgnoreCase);
上面介绍了几个选项如忽略大小写，处理多行等，这些选项能用来改变处理正则表达式的方式。下面是.Net中常用的正则表达式选项：
表6.常用的处理选项
名称	说明
IgnoreCase(忽略大小写)	匹配时不区分大小写。
Multiline(多行模式)	更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)
Singleline(单行模式)	更改.的含义，使它与每一个字符匹配（包括换行符\n）。
IgnorePatternWhitespace(忽略空白)	忽略表达式中的非转义空白并启用由#标记的注释。
ExplicitCapture(显式捕获)	仅捕获已被显式命名的组。
一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。
平衡组/递归匹配

这里介绍的平衡组语法是由.Net Framework支持的；其它语言／库不一定支持这种功能，或者支持此功能但需要使用不同的语法。
有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用\(.+\)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如( 5 / ( 3 + 2 ) ) )，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？
为了避免(和\(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把xx <aa <bbb> <bbb> aa> yy这样的字符串里，最长的配对的尖括号内的内容捕获出来？
这里需要用到以下的语法构造：
(?'group') 把捕获的内容命名为group,并压入堆栈(Stack)
(?'-group') 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败
(?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分
(?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败
如果你不是一个程序员（或者你自称程序员但是不知道堆栈是什么东西），你就这样理解上面的三种语法吧：第一个就是在黑板上写一个"group"，第二个就是从黑板上擦掉一个"group"，第三个就是看黑板上写的还有没有"group"，如果有就继续匹配yes部分，否则就匹配no部分。
我们需要做的是每碰到了左括号，就在压入一个"Open",每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。
<                         #最外层的左括号
    [^<>]*                #最外层的左括号后面的不是括号的内容
    (
        (
            (?'Open'<)    #碰到了左括号，在黑板上写一个"Open"
            [^<>]*       #匹配左括号后面的不是括号的内容
        )+
        (
            (?'-Open'>)   #碰到了右括号，擦掉一个"Open"
            [^<>]*        #匹配右括号后面不是括号的内容
        )+
    )*
    (?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的"Open"；如果还有，则匹配失败

>                         #最外层的右括号
平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的<div>标签：<div[^>]*>[^<>]*(((?'Open'<div[^>]*>)[^<>]*)+((?'-Open'</div>)[^<>]*)+)*(?(Open)(?!))</div>.
还有些什么东西没提到

上边已经描述了构造正则表达式的大量元素，但是还有很多没有提到的东西。下面是一些未提到的元素的列表，包含语法和简单的说明。你可以在网上找到更详细的参考资料来学习它们--当你需要用到它们的时候。如果你安装了MSDN Library,你也可以在里面找到.net下正则表达式详细的文档。
这里的介绍很简略，如果你需要更详细的信息，而又没有在电脑上安装MSDN Library,可以查看关于正则表达式语言元素的MSDN在线文档。
表7.尚未详细讨论的语法
代码/语法	说明
\a	报警字符(打印它的效果是电脑嘀一声)
\b	通常是单词分界位置，但如果在字符类里使用代表退格
\t	制表符，Tab
\r	回车
\v	竖向制表符
\f	换页符
\n	换行符
\e	Escape
\0nn	ASCII代码中八进制代码为nn的字符
\xnn	ASCII代码中十六进制代码为nn的字符
\unnnn	Unicode代码中十六进制代码为nnnn的字符
\cN	ASCII控制字符。比如\cC代表Ctrl+C
\A	字符串开头(类似^，但不受处理多行选项的影响)
\Z	字符串结尾或行尾(不受处理多行选项的影响)
\z	字符串结尾(类似$，但不受处理多行选项的影响)
\G	当前搜索的开头
\p{name}	Unicode中命名为name的字符类，例如\p{IsGreek}
(?>exp)	贪婪子表达式
(?<x>-<y>exp)	平衡组
(?im-nsx:exp)	在子表达式exp中改变处理选项
(?im-nsx)	为表达式后面的部分改变处理选项
(?(exp)yes|no)	把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no
(?(exp)yes)	同上，只是使用空表达式作为no
(?(name)yes|no)	如果命名为name的组捕容，使用yes作为表达式；否则使用no
(?(name)yes)	同上，只是使用空表达式作为no

*************************************************************************************
End					regex    				  End
*************************************************************************************

0310
     Idles, timeouts, and input functions from GLib, such as g_idle_add(), are executed outside of the main GTK+      lock. So, if you need to call GTK+ inside of such a callback, you must surround the callback with a      gdk_threads_enter()/gdk_threads_leave() pair or use gdk_threads_add_idle_full() which does this for you.      However,      event dispatching from the mainloop is still executed within the main GTK+ lock, so callback functions connected      to event signals like GtkWidget::button-press-event, do not need thread protection.


0311 
     Initializes GDK so that it can be used from multiple threads in conjunction with gdk_threads_enter() and              gdk_threads_leave(). g_thread_init() must be called previous to this function. 
     This call must be made before any use of the main loop from GTK+; to be safe, call it before gtk_init(). 
     

0316
     Fügen Sie ein Debian-Backports-Archiv zu /etc/apt/sources.list hinzu, verwenden Sie auch den "non-free"-Komponenten. Beispiel: 

# Backported packages for Debian Lenny
deb http://backports.debian.org/debian-backports lenny-backports main contrib non-freeFühren Sie ein Update der Liste und der Pakete durch: 

aptitude updateInstallieren Sie einen für Ihr System geeigneten 2.6.32 Kernel zusammen mit den lenny-backports/firmware-ralink und den wireless-tools Paketen. 

 ACHTUNG: Führen Sie dringend ein Backup Ihrer Dateien für der Installation des neuen Kernels durch! Während der Installation des neuen Kernels werden Sie nach der bevorzugten Kommandozeile für System gefragt. Es ist vielleicht ratsam nicht sh sondern bash zu nehmen (diverse Vorfälle in der Vergangenheit). 

Beispiel: 

aptitude -t lenny-backports install linux-image-2.6-$(uname -r | sed 's,.*-,,') firmware-ralink wireless-toolsSetzen Sie den alten Treiber rt2800usb auf die Blacklist, damit rt2870sta nicht am Ausführen gehindert wird: 

echo "blacklist rt2800usb" >> /etc/modprobe.d/blacklistStarten Sie Ihr System neu und booten Sie von dem 32er-Kernel. Anschließend verbinden Sie Ihren Laptop oder Computer mit dem jeweiligem Gerät. 
Die notwendigen Kernel-Module sollten automatisch geladen werden. Falls dies nicht zutrifft kann das Modul mit dem folgendem Befehl manuell geladen werden: 

modprobe rt2870staDer 32er-Kernel von Debian verfügt über einen Netzwerk-Manager, der das einfache Verbinden über eine graphische Benutzeroberfläche mit (W)LAN-Netzwerken gewährleistet. Sollte dies nicht der Fall sein, so können Sie mit dem folgendem Befehl den Netzwerk-Manager installieren: 

aptitude install network-manager






0321 
*******************************************************************************
					Start
*******************************************************************************
Name
wpa_supplicant.conf - configuration file for wpa_supplicant 

Overview
wpa_supplicant is configured using a text file that lists all accepted networks and security policies, including pre-shared keys. See the example configuration file, probably in /usr/share/doc/wpa_supplicant/, for detailed information about the configuration format and supported fields. 

All file paths in this configuration file should use full (absolute, not relative to working directory) path in order to allow working directory to be changed. This can happen if wpa_supplicant is run in the background. 

Changes to configuration file can be reloaded be sending SIGHUP signal to wpa_supplicant ('killall -HUP wpa_supplicant'). Similarly, reloading can be triggered with 

Configuration file can include one or more network blocks, e.g., one for each used SSID. wpa_supplicant will automatically select the best betwork based on the order of network blocks in the configuration file, network security level (WPA/WPA2 is prefered), and signal strength. 

Quick Examples
1. 
WPA-Personal (PSK) as home network and WPA-Enterprise with EAP-TLS as work network. 

# allow frontend (e.g., wpa_cli) to be used by all users in 'wheel' group
ctrl_interface=/var/run/wpa_supplicant
ctrl_interface_group=wheel
#
# home network; allow all valid ciphers
network={
ssid="home" 
scan_ssid=1 

key_mgmt=WPA-PSK 

psk="very secret passphrase" 

}
#
# work network; use EAP-TLS with WPA; allow only CCMP and TKIP ciphers
network={ 
ssid="work" 
scan_ssid=1 

key_mgmt=WPA-EAP 

pairwise=CCMP TKIP 

group=CCMP TKIP 

eap=TLS 

identity="user@example.com" 

ca_cert="/etc/cert/ca.pem" 

client_cert="/etc/cert/user.pem" 

private_key="/etc/cert/user.prv" 

private_key_passwd="password" 

} 
2. 
WPA-RADIUS/EAP-PEAP/MSCHAPv2 with RADIUS servers that use old peaplabel (e.g., Funk Odyssey and SBR, Meetinghouse Aegis, Interlink RAD-Series) 

ctrl_interface=/var/run/wpa_supplicant
ctrl_interface_group=wheel
network={
ssid="example" 
scan_ssid=1 

key_mgmt=WPA-EAP 

eap=PEAP 

identity="user@example.com" 

password="foobar" 

ca_cert="/etc/cert/ca.pem" 

phase1="peaplabel=0" 

phase2="auth=MSCHAPV2" 

} 
3. 
EAP-TTLS/EAP-MD5-Challenge configuration with anonymous identity for the unencrypted use. Real identity is sent only within an encrypted TLS tunnel. 

ctrl_interface=/var/run/wpa_supplicant
ctrl_interface_group=wheel
network={
ssid="example" 
scan_ssid=1 

key_mgmt=WPA-EAP 

eap=TTLS 

identity="user@example.com" 

anonymous_identity="anonymous@example.com" 

password="foobar" 

ca_cert="/etc/cert/ca.pem" 

phase2="auth=MD5" 

} 
4. 
IEEE 802.1X (i.e., no WPA) with dynamic WEP keys (require both unicast and broadcast); use EAP-TLS for authentication 

ctrl_interface=/var/run/wpa_supplicant
ctrl_interface_group=wheel
network={
ssid="1x-test" 
scan_ssid=1 

key_mgmt=IEEE8021X 

eap=TLS 

identity="user@example.com" 

ca_cert="/etc/cert/ca.pem" 

client_cert="/etc/cert/user.pem" 

private_key="/etc/cert/user.prv" 

private_key_passwd="password" 

eapol_flags=3 

} 
5. 
Catch all example that allows more or less all configuration modes. The configuration options are used based on what security policy is used in the selected SSID. This is mostly for testing and is not recommended for normal use. 

ctrl_interface=/var/run/wpa_supplicant
ctrl_interface_group=wheel
network={
ssid="example" 
scan_ssid=1 

key_mgmt=WPA-EAP WPA-PSK IEEE8021X NONE 

pairwise=CCMP TKIP 

group=CCMP TKIP WEP104 WEP40 

psk="very secret passphrase" 

eap=TTLS PEAP TLS 

identity="user@example.com" 

password="foobar" 

ca_cert="/etc/cert/ca.pem" 

client_cert="/etc/cert/user.pem" 

private_key="/etc/cert/user.prv" 

private_key_passwd="password" 

phase1="peaplabel=0" 

ca_cert2="/etc/cert/ca2.pem" 

client_cert2="/etc/cer/user.pem" 

private_key2="/etc/cer/user.prv" 

private_key2_passwd="password" 

} 
6. 
Authentication for wired Ethernet. This can be used with 

ctrl_interface=/var/run/wpa_supplicant
ctrl_interface_group=wheel
ap_scan=0
network={
key_mgmt=IEEE8021X 
eap=MD5 

identity="user" 

password="password" 

eapol_flags=0 

} 
Certificates
Some EAP authentication methods require use of certificates. EAP-TLS uses both server side and client certificates whereas EAP-PEAP and EAP-TTLS only require the server side certificate. When client certificate is used, a matching private key file has to also be included in configuration. If the private key uses a passphrase, this has to be configured in wpa_supplicant.conf ("private_key_passwd"). 

wpa_supplicant supports X.509 certificates in PEM and DER formats. User certificate and private key can be included in the same file. 

If the user certificate and private key is received in PKCS#12/PFX format, they need to be converted to suitable PEM/DER format for wpa_supplicant. This can be done, e.g., with following commands: 

# convert client certificate and private key to PEM format
openssl pkcs134-in example.pfx -out user.pem -clcerts
# convert CA certificate (if included in PFX file) to PEM format
openssl pkcs12 -in example.pfx -out ca.pem -cacerts -nokeys
	
*******************************************************************************
					End
*******************************************************************************

0322
WEP:
     ctrl_interface=/var/run/wpa_supplicant
     network=
     {
        ssid="Elon-AP"
        	key_mgmt=NONE
        	wep_key0="31325"
     }
     
WPA: 
     
0325 第一个参数是要打开文件的名字(路径),第二个参数是打开文件所用的模式.对于模式参数的”w”和”wb”,”r”和”rb”,我起     初并不是很理解,按照课本上的说法,”w”是以文本的形式进行写入,而”wb”是以二进制模式进行写入.这样的解释令人感觉有     点玄乎     ,不能准确理解.
     最近写了个小程序，把数据以16进制的形式存到一个文件中，当从文件中读取时，发现读取的数据不对，进行调试时，发现读取   的数据与写入文件中的数据发生了错位，进行调试发现写入时并没有错误，读取时，怎么就发生错位了呢？调试了半天发现每遇到        0x0A，在它前面就会多一个0x0D.
    那么，是什么原因造成的呢？几经周折之后，终于发现是fopen的参数引起的.如果这么写：fp = fopen(str,"wb");可以得到正     常数据，而fp = fopen(str,"w");就得不到正常数据，遇到0x0A时，就会在其前面多一个0x0D.
         原来，如果有参数b,是以二进制方式打开,这种方式不会进行”回车符”和”换行符”的转换.而如果没有b,即单以          style="FONT-FAMILY: Times New Roman; mso-bidi-font-size: 10.5pt">”w”为参数的话,系统就把换行符0A转换为0D0A,因为      windows是以0D0A为换行符的.
     至此,总算是弄明白了所谓二进制打开和文本打开的区别,真晕
     
     
     
0329 

How could I get any widgets position?
As Tim Janik pointed out, there are different cases, and each case requires a different solution.
If you want the position of a widget relative to its parent, you should use widget->allocation.x and widget->allocation.y.

If you want the position of a window relative to the X root window, you should use gdk_window_get_geometry() gdk_window_get_position() or gdk_window_get_origin().

If you want to get the position of the window (including the WM decorations), you should use gdk_window_get_root_origin().

Last but not least, if you want to get a 
  Window Manager frame position, you should use gdk_window_get_deskrelative_origin().

Your choice of Window Manager will have an effect of the results of the above functions. You should keep this in mind when writing your application. This is dependant upon how the Window Managers manage the decorations that they add around windows.

gdk_window_get_origin: position of X?
	




0427
 typedef struct 
{
  GdkFontType type;
  gint ascent;
  gint descent;
} GdkFont;

    typedef enum
{
  GDK_FONT_FONT,
  GDK_FONT_FONTSET
} GdkFontType;

typedef enum
{
  GDK_RGB_DITHER_NONE,
  GDK_RGB_DITHER_NORMAL,
  GDK_RGB_DITHER_MAX
} GdkRgbDither;


0506 C string containing a file access modes. It can be:
   "r" Open a file for reading. The file must exist. 
"w" Create an empty file for writing. If a file with the same name already exists its content is erased and the file is treated as a new empty file.  
"a" Append to a file. Writing operations append data at the end of the file. The file is created if it does not exist. 
"r+" Open a file for update both reading and writing. The file must exist. 
"w+" Create an empty file for both reading and writing. If a file with the same name already exists its content is erased and the file is treated as a new empty file. 
"a+" Open a file for reading and appending. All writing operations are performed at the end of the file, protecting the previous content to be overwritten. You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations will move it back to the end of file. The file is created if it does not exist. 


fopen是标准c里的,而open是linux的系统调用.fopen可移植,open不能
缓冲文件系统是借助文件结构体指针来对文件进行管理，通过文件指针来对文件进行访问，既可以读写字符、字符串、格式化数据，也可以读写二进制数 据。非缓冲文件系统依赖于操作系统，通过操作系统的功能对文件进行读写，是系统级的输入输出，它不设文件结构体指针，只能读写二进制文件，但效率高、速度 快，由于ANSI标准不再包括非缓冲文件系统，因此建议大家最好不要选择它。本书只作简单介绍。open, close, read, write, getc, getchar, putc, putchar 等
前者属于低级IO，后者是高级IO。
前者返回一个文件描述符(用户程序区的)，后者返回一个文件指针。



定义函数  int open( const char * pathname, int flags);
int open( const char * pathname,int flags, mode_t mode);
 
函数说明  参数pathname 指向欲打开的文件路径字符串。下列是参数flags 所能使用的旗标:
O_RDONLY 以只读方式打开文件
O_WRONLY 以只写方式打开文件
O_RDWR 以可读写方式打开文件。上述三种旗标是互斥的，也就是不可同时使用，但可与下列的旗标利用OR(|)运算符组合。
O_CREAT 若欲打开的文件不存在则自动建立该文件。
O_EXCL 如果O_CREAT 也被设置，此指令会去检查文件是否存在。文件若不存在则建立该文件，否则将导致打开文件错误。此外，若O_CREAT与O_EXCL同时设置，并且欲打开的文件为符号连接，则会打开文件失败。
O_NOCTTY 如果欲打开的文件为终端机设备时，则不会将该终端机当成进程控制终端机。
O_TRUNC 若文件存在并且以可写的方式打开时，此旗标会令文件长度清为0，而原来存于该文件的资料也会消失。
O_APPEND 当读写文件时会从文件尾开始移动，也就是所写入的数据会以附加的方式加入到文件后面。
O_NONBLOCK 以不可阻断的方式打开文件，也就是无论有无数据读取或等待，都会立即返回进程之中。
O_NDELAY 同O_NONBLOCK。
O_SYNC 以同步的方式打开文件。
O_NOFOLLOW 如果参数pathname 所指的文件为一符号连接，则会令打开文件失败。
O_DIRECTORY 如果参数pathname 所指的文件并非为一目录，则会令打开文件失败。
此为Linux2.2以后特有的旗标，以避免一些系统安全问题。参数mode 则有下列数种组合，只有在建立新文件时才会生效，此外真正建文件时的权限会受到umask值所影响，因此该文件权限应该为（mode-umaks）。
S_IRWXU00700 权限，代表该文件所有者具有可读、可写及可执行的权限。
S_IRUSR 或S_IREAD，00400权限，代表该文件所有者具有可读取的权限。
S_IWUSR 或S_IWRITE，00200 权限，代表该文件所有者具有可写入的权限。
S_IXUSR 或S_IEXEC，00100 权限，代表该文件所有者具有可执行的权限。
S_IRWXG 00070权限，代表该文件用户组具有可读、可写及可执行的权限。
S_IRGRP 00040 权限，代表该文件用户组具有可读的权限。
S_IWGRP 00020权限，代表该文件用户组具有可写入的权限。
S_IXGRP 00010 权限，代表该文件用户组具有可执行的权限。
S_IRWXO 00007权限，代表其他用户具有可读、可写及可执行的权限。
S_IROTH 00004 权限，代表其他用户具有可读的权限
S_IWOTH 00002权限，代表其他用户具有可写入的权限。
S_IXOTH 00001 权限，代表其他用户具有可执行的权限。
 
返回值  若所有欲核查的权限都通过了检查则返回0 值，表示成功，只要有一个权限被禁止则返回-1。
 
错误代码  EEXIST 参数pathname 所指的文件已存在，却使用了O_CREAT和O_EXCL旗标。
EACCESS 参数pathname所指的文件不符合所要求测试的权限。
EROFS 欲测试写入权限的文件存在于只读文件系统内。
EFAULT 参数pathname指针超出可存取内存空间。
EINVAL 参数mode 不正确。
ENAMETOOLONG 参数pathname太长。
ENOTDIR 参数pathname不是目录。
ENOMEM 核心内存不足。
ELOOP 参数pathname有过多符号连接问题。
EIO I/O 存取错误。
 
附加说明  使用access()作用户认证方面的判断要特别小心，例如在access()后再作open()空文件可能会造成系统安全上的问题。
 
范例  #include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
main()
{
int fd,size;
char s [ ]=”Linux Programmer!\n”,buffer[80];
fd=open(“/tmp/temp”,O_WRONLY|O_CREAT);
write(fd,s,sizeof(s));
close(fd);
fd=open(“/tmp/temp”,O_RDONLY);
size=read(fd,buffer,sizeof(buffer));
close(fd);
printf(“%s”,buffer);
}
 

0520 
struct ifaddrs {
	struct ifaddrs  *ifa_next;
	char		*ifa_name;
	u_int		 ifa_flags;
	struct sockaddr	*ifa_addr;
	struct sockaddr	*ifa_netmask;
	struct sockaddr	*ifa_dstaddr;
	void		*ifa_data;
};
struct sockaddr { 　
			unsigned short sa_family; /* address family, AF_xxx */ 　
　			char sa_data[14]; /* 14 bytes of protocol address */ 　
		}; 

struct sockaddr_in { 　　
		    short int sin_family; /* Address family */ 　
		  　unsigned short int sin_port; /* Port `*/ 　
                  　struct in_addr sin_addr; /* Internet address */ 　　
		    unsigned char sin_zero[8]; /* Same size as struct sockaddr */ 　　
		   };

in_addr 用来表示一个32位的IPv4地址.
in_addr_t 一般为 32位的unsigned long. 
其中每8位代表一个IP地址位中的一个数值. 　　
例如192.168.3.144记为0xc0a80390, 其中 c0 为192 ,a8 为 168, 03 为 3 , 90 为 144 　　
打印的时候可以调用inet_ntoa()函数将其转换为char *类型.
struct in_addr {
		in_addr_t s_addr; 　　
	       };
int inet_addr
struct hostent { 
　　 char   *h_name       Official name of the host. 
     char  **h_aliases    A pointer to an array of pointers to 
                          alternative host names, terminated by a 
                          null pointer. 
     int     h_addrtype   Address type. 
     int     h_length     The length, in bytes, of the address. 
     char  **h_addr_list  A pointer to an array of pointers to network 
                          addresses (in network byte order) for the host, 
                          terminated by a null pointer.
　　 }; 

gethostaddr
 

0531 Linphone depends on the mandatory following source packages: 

     speex>=1.2.0 with libspeexdsp 
     libosip2>=3.1.0
libeXosip2>=3.1.0 
Those additional packages are recommended: 

alsa-lib (libasound): the alsa library, usually present on all linux now. 
ffmpeg (more specifically libavcodec) for video codec support 
SDL>=1.2.9 again to video support working 
gtk+>=2.16 for the graphical interface 
libtheora>=1.0 to use the theora codec for an efficent video streaming 
libreadline (makes linphonec usage easier) 
If you use binary packages (rpm, deb) which is the easiest way to have all linphone build dependencies on a system, install the *-dev (deb) or *-devel (rpm) packages of the above mentioned source packages. 











#include <arpa/inet.h>

const char *inet_ntop(int af, const void *restrict src,
       char *restrict dst, socklen_t size);

   
  十六进制：支持10位或26位十六进制字符
  ASCII：支持5位或13位ACSII字符



getrusage() returns current resource usages, for a who of either RUSAGE_SELF or RUSAGE_CHILDREN. The former asks for resources used by the current process, the latter for resources used by those of its children that have terminated and have been waited for. 
struct rusage {
    struct timeval ru_utime; /* user time used */
    struct timeval ru_stime; /* system time used */
    long   ru_maxrss;        /* maximum resident set size */
    long   ru_ixrss;         /* integral shared memory size */
    long   ru_idrss;         /* integral unshared data size */
    long   ru_isrss;         /* integral unshared stack size */
    long   ru_minflt;        /* page reclaims */
    long   ru_majflt;        /* page faults */
    long   ru_nswap;         /* swaps */
    long   ru_inblock;       /* block input operations */
    long   ru_oublock;       /* block output operations */
    long   ru_msgsnd;        /* messages sent */
    long   ru_msgrcv;        /* messages received */
    long   ru_nsignals;      /* signals received */
    long   ru_nvcsw;         /* voluntary context switches */
    long   ru_nivcsw;        /* involuntary context switches */

};

disk:
du df

NAT是一种将私有(保留)地址转化为合法IP地址的转换技术




-------------------------------------------
-b file 如果文件为一个块特殊文件，则为真
-c file 如果文件为一个字符特殊文件，则为真
-d file 如果文件为一个目录，则为真
-e file 如果文件存在，则为真
-f file 如果文件为一个普通文件，则为真
-g file 如果设置了文件的 SGID 位，则为真
-G file 如果文件存在且归该组所有，则为真
-k file 如果设置了文件的粘着位，则为真
-O file 如果文件存在并且归该用户所有，则为真
-p file 如果文件为一个命名管道，则为真
-r file 如果文件可读，则为真
-s file 如果文件的长度不为零，则为真
-S file 如果文件为一个套接字特殊文件，则为真
-t fd 如果 fd 是一个与终端相连的打开的文件描述符（fd 默认为 1），则为真
-u file 如果设置了文件的 SUID 位，则为真
-w file 如果文件可写，则为真
-x file 如果文件可执行，则为真


freopen("/var/log/syslog","a", stderr);



------------------------------------------------------------------------------------------
Linux 套接字编程中的 5 个隐患
在异构环境中开发可靠的网络应用程序
M. Tim Jones (mtj@mtjones.com), 资深软件工程师, Emulex
简介： Socket API 是网络应用程序开发中实际应用的标准 API。尽管该 API 简单，但是开发新手可能会经历一些常见的问题。本文识别一些最常见的隐患并向您显示如何避免它们。
标记本文！
发布日期： 2005 年 10 月 08 日 
级别： 中级 
访问情况 ： 4280 次浏览 
评论： 0 (查看 | 添加评论 - 登录)
 平均分 (2个评分)
为本文评分

在 4.2 BSD UNIX® 操作系统中首次引入，Sockets API 现在是任何操作系统的标准特性。事实上，很难找到一种不支持 Sockets API 的现代语言。该 API 相当简单，但新的开发人员仍然会遇到一些常见的隐患。
本文识别那些隐患并向您显示如何避开它们。
隐患 1．忽略返回状态
第一个隐患很明显，但它是开发新手最容易犯的一个错误。如果您忽略函数的返回状态，当它们失败或部分成功的时候，您也许会迷失。反过来，这可能传播错误，使定位问题的源头变得困难。
捕获并检查每一个返回状态，而不是忽略它们。考虑清单 1 显示的例子，一个套接字 send 函数。

清单 1. 忽略 API 函数返回状态

int status, sock, mode;
/* Create a new stream (TCP) socket */
sock = socket( AF_INET, SOCK_STREAM, 0 );
...
status = send( sock, buffer, buflen, MSG_DONTWAIT );
if (status == -1) {
  /* send failed */
  printf( "send failed: %s\n", strerror(errno) );
} else {
  /* send succeeded -- or did it? */
}

清单 1 探究一个函数片断，它完成套接字 send 操作（通过套接字发送数据）。函数的错误状态被捕获并测试，但这个例子忽略了 send 在无阻塞模式（由 MSG_DONTWAIT 标志启用）下的一个特性。
send API 函数有三类可能的返回值：
如果数据成功地排到传输队列，则返回 0。
如果排队失败，则返回 -1（通过使用 errno 变量可以了解失败的原因）。
如果不是所有的字符都能够在函数调用时排队，则最终的返回值是发送的字符数。
由于 send 的 MSG_DONTWAIT 变量的无阻塞性质，函数调用在发送完所有的数据、一些数据或没有发送任何数据后返回。在这里忽略返回状态将导致不完全的发送和随后的数据丢失。
回页首
隐患 2．对等套接字闭包
UNIX 有趣的一面是您几乎可以把任何东西看成是一个文件。文件本身、目录、管道、设备和套接字都被当作文件。这是新颖的抽象，意味着一整套的 API 可以用在广泛的设备类型上。
考虑 read API 函数，它从文件读取一定数量的字节。read 函数返回读取的字节数（最高为您指定的最大值）；或者 -1，表示错误；或者 0，如果已经到达文件末尾。
如果在一个套接字上完成一个 read 操作并得到一个为 0 的返回值，这表明远程套接字端的对等层调用了 close API 方法。该指示与文件读取相同 —— 没有多余的数据可以通过描述符读取（参见 清单 2）。

清单 2．适当处理 read API 函数的返回值

int sock, status;
sock = socket( AF_INET, SOCK_STREAM, 0 );
...
status = read( sock, buffer, buflen );
if (status > 0) {
  /* Data read from the socket */
} else if (status == -1) {
  /* Error, check errno, take action... */
} else if (status == 0) {
  /* Peer closed the socket, finish the close */
  close( sock );
  /* Further processing... */
}

同样，可以用 write API 函数来探测对等套接字的闭包。在这种情况下，接收 SIGPIPE 信号，或如果该信号阻塞，write 函数将返回 -1 并设置 errno 为 EPIPE。
回页首
隐患 3．地址使用错误（EADDRINUSE）
您可以使用 bind API 函数来绑定一个地址（一个接口和一个端口）到一个套接字端点。可以在服务器设置中使用这个函数，以便限制可能有连接到来的接口。也可以在客户端设置中使用这个函数，以便限制应当供出去的连接所使用的接口。bind 最常见的用法是关联端口号和服务器，并使用通配符地址（INADDR_ANY），它允许任何接口为到来的连接所使用。
bind 普遍遭遇的问题是试图绑定一个已经在使用的端口。该陷阱是也许没有活动的套接字存在，但仍然禁止绑定端口（bind 返回 EADDRINUSE），它由 TCP 套接字状态 TIME_WAIT 引起。该状态在套接字关闭后约保留 2 到 4 分钟。在 TIME_WAIT 状态退出之后，套接字被删除，该地址才能被重新绑定而不出问题。
等待 TIME_WAIT 结束可能是令人恼火的一件事，特别是如果您正在开发一个套接字服务器，就需要停止服务器来做一些改动，然后重启。幸运的是，有方法可以避开 TIME_WAIT 状态。可以给套接字应用 SO_REUSEADDR 套接字选项，以便端口可以马上重用。
考虑清单 3 的例子。在绑定地址之前，我以 SO_REUSEADDR 选项调用 setsockopt。为了允许地址重用，我设置整型参数（on）为 1 （不然，可以设为 0 来禁止地址重用）。

清单 3．使用 SO_REUSEADDR 套接字选项避免地址使用错误

int sock, ret, on;
struct sockaddr_in servaddr;
/* Create a new stream (TCP) socket */
sock = socket( AF_INET, SOCK_STREAM, 0 ):
/* Enable address reuse */
on = 1;
ret = setsockopt( sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on) );
/* Allow connections to port 8080 from any available interface */
memset( &servaddr, 0, sizeof(servaddr) );
servaddr.sin_family = AF_INET;
servaddr.sin_addr.s_addr = htonl( INADDR_ANY );
servaddr.sin_port = htons( 45000 );
/* Bind to the address (interface/port) */
ret = bind( sock, (struct sockaddr *)&servaddr, sizeof(servaddr) );

在应用了 SO_REUSEADDR 选项之后，bind API 函数将允许地址的立即重用。
回页首
隐患 4．发送结构化数据
套接字是发送无结构二进制字节流或 ASCII 数据流（比如 HTTP 上的 HTTP 页面，或 SMTP 上的电子邮件）的完美工具。但是如果试图在一个套接字上发送二进制数据，事情将会变得更加复杂。
比如说，您想要发送一个整数：您可以肯定，接收者将使用同样的方式来解释该整数吗？运行在同一架构上的应用程序可以依赖它们共同的平台来对该类型的数据做出相同的解释。但是，如果一个运行在高位优先的 IBM PowerPC 上的客户端发送一个 32 位的整数到一个低位优先的 Intel x86，那将会发生什么呢？字节排列将引起不正确的解释。
字节交换还是不呢？
Endianness 是指内存中字节的排列顺序。高位优先（big endian） 按最高有效字节在前排列，然而 低位优先（little endian） 按照最低有效字节在前排序。
高位优先架构（比如 PowerPC®）比低位优先架构（比如 Intel® Pentium® 系列，其网络字节顺序是高位优先）有优势。这意味着，对高位优先的机器来说，在 TCP/IP 内控制数据是自然有序的。低位优先架构要求字节交换 —— 对网络应用程序来说，这是一个轻微的性能弱点。
通过套接字发送一个 C 结构会怎么样呢？这里，也会遇到麻烦，因为不是所有的编译器都以相同的方式排列一个结构的元素。结构也可能被压缩以便使浪费的空间最少，这进一步使结构中的元素错位。
幸好，有解决这个问题的方案，能够保证两端数据的一致解释。过去，远程过程调用（Remote Procedure Call，RPC）套装工具提供所谓的外部数据表示（External Data Representation，XDR）。XDR 为数据定义一个标准的表示来支持异构网络应用程序通信的开发。
现在，有两个新的协议提供相似的功能。可扩展标记语言/远程过程调用（XML/RPC）以 XML 格式安排 HTTP 上的过程调用。数据和元数据用 XML 进行编码并作为字符串传输，并通过主机架构把值和它们的物理表示分开。SOAP 跟随 XML-RPC，以更好的特性和功能扩展了它的思想。参见 参考资料 小节，获取更多关于每个协议的信息。
回页首
隐患 5．TCP 中的帧同步假定
TCP 不提供帧同步，这使得它对于面向字节流的协议是完美的。这是 TCP 与 UDP（User Datagram Protocol，用户数据报协议）的一个重要区别。UDP 是面向消息的协议，它保留发送者和接收者之间的消息边界。TCP 是一个面向流的协议，它假定正在通信的数据是无结构的，如图 1 所示。

图 1．UDP 的帧同步能力和缺乏帧同步的 TCP
 
图 1 的上部说明一个 UDP 客户端和服务器。左边的对等层完成两个套接字的写操作，每个 100 字节。协议栈的 UDP 层追踪写的数量，并确保当右边的接收者通过套接字获取数据时，它以同样数量的字节到达。换句话说，为读者保留了写者提供的消息边界。
现在，看图 1 的底部．它为 TCP 层演示了相同粒度的写操作。两个独立的写操作（每个 100 字节）写入流套接字。但在本例中，流套接字的读者得到的是 200 字节。协议栈的 TCP 层聚合了两次写操作。这种聚合可以发生在 TCP/IP 协议栈的发送者或接收者中任何一方。重要的是，要注意到聚合也许不会发生 —— TCP 只保证数据的有序发送。
对大多数开发人员来说，该陷阱会引起困惑。您想要获得 TCP 的可靠性和 UDP 的帧同步。除非改用其他的传输协议，比如流传输控制协议（STCP），否则就要求应用层开发人员来实现缓冲和分段功能。
回页首
调试套接字应用程序的工具
GNU/Linux 提供几个工具，它们可以帮助您发现套接字应用程序中的一些问题。此外，使用这些工具还有教育意义，而且能够帮助解释应用程序和 TCP/IP 协议栈的行为。在这里，您将看到对几个工具的概述。查阅下面的 参考资料 了解更多的信息。
查看网络子系统的细节
netstat 工具提供查看 GNU/Linux 网络子系统的能力。使用 netstat，可以查看当前活动的连接（按单个协议进行查看），查看特定状态的连接（比如处于监听状态的服务器套接字）和许多其他的信息。清单 4 显示了 netstat 提供的一些选项和它们启用的特性。

清单 4．netstat 实用程序的用法模式

View all TCP sockets currently active
$ netstat --tcp
View all UDP sockets
$ netstat --udp
View all TCP sockets in the listening state
$ netstat --listening
View the multicast group membership information
$ netstat --groups
Display the list of masqueraded connections
$ netstat --masquerade
View statistics for each protocol
$ netstat --statistics

尽管存在许多其他的实用程序，但 netstat 的功能很全面，它覆盖了 route、ifconfig 和其他标准 GNU/Linux 工具的功能。
监视流量
可以使用 GNU/Linux 的几个工具来检查网络上的低层流量。tcpdump 工具是一个比较老的工具，它从网上“嗅探”网络数据包，打印到 stdout 或记录在一个文件中。该功能允许查看应用程序产生的流量和 TCP 生成的低层流控制机制。一个叫做 tcpflow 的新工具与 tcpdump 相辅相成，它提供协议流分析和适当地重构数据流的方法，而不管数据包的顺序或重发。清单 5 显示 tcpdump 的两个用法模式。

清单 5．tcpdump 工具的用法模式

Display all traffic on the eth0 interface for the local host
$ tcpdump -l -i eth0
Show all traffic on the network coming from or going to host plato
$ tcpdump host plato
Show all HTTP traffic for host camus
$ tcpdump host camus and (port http)
View traffic coming from or going to TCP port 45000 on the local host
$ tcpdump tcp port 45000

tcpdump 和 tcpflow 工具有大量的选项，包括创建复杂过滤表达式的能力。查阅下面的 参考资料 获取更多关于这些工具的信息。
tcpdump 和 tcpflow 都是基于文本的命令行工具。如果您更喜欢图形用户界面（GUI），有一个开放源码工具 Ethereal 也许适合您的需要。Ethereal 是一个专业的协议分析软件，它可以帮助调试应用层协议。它的插入式架构（plug-in architecture）可以分解协议，比如 HTTP 和您能想到的任何协议（写本文的时候共有 637 个协议）。
回页首
总结
套接字编程是容易而有趣的，但是您要避免引入错误或至少使它们容易被发现，这就需要考虑本文中描述的这 5 个常见的陷阱，并且采用标准的防错性程序设计实践。GNU/Linux 工具和实用程序还可以帮助发现一些程序中的小问题。记住：在查看实用程序的帮助手册时候，跟踪相关的或“请参见”工具。您也许会发现一个必要的新工具。

参考资料
学习
您可以参阅本文在 developerWorks 全球站点上的 英文原文。

TCP 状态机有 11 个状态。参见 W. Richard Steven 的 illustration from TCP/IP Illustrated, Volume 1 一书。

在 Wikipedia 上探究 Endianness 的历史和含意。

了解更多关于 IBM 的开放式、可伸缩和可定制的 Power Architecture 的信息。

从 Programming in C 课件阅读 RPC/XDR 简介。

获取更多关于 XML-RPC 以及在 Java™ 应用程序中如何使用它的信息，请阅读 “Java 编程中的 XML-RPC” （developerWorks，2004 年 1 月）。

SOAP 以 XML-RPC 的特性为基础。请在 SoapWare.Org 上查找规范、工具、教程和文章。

SCTP 兼有 TCP 和 UDP 的特性，以及可用性和可靠性。

教程 “Linux Socket 编程，第一部分” （developerWorks，2003 年 10 月）讲解如何开始套接字编程以及如何构建一个通过 TCP/IP 连接的 echo 服务器和客户端。“Linux Socket 编程，第二部分” （developerWorks，2004 年 1 月）集中讨论 UDP 并且讲解如何用 C 和 Python 编写 UDP 套接字应用程序（尽管代码会翻译为其他语言）。

netstat 手册页 提供有关各种使用 netstat 的方法的细节。

BSD Sockets Programming from a Multilanguage Perspective （作者 M. Tim Jones），用 6 种不同的语言介绍了套接字编程的技巧。

在 developerWorks Linux 专区 上查找更多为 Linux 开发人员提供的参考资料。 
-------------------------------------------------------------------------------------------









--------------------------------------
NAME

setsockopt - set the socket options
SYNOPSIS

#include <sys/socket.h>

int setsockopt(int socket, int level, int option_name,
       const void *option_value, socklen_t option_len);

DESCRIPTION

The setsockopt() function shall set the option specified by the option_name argument, at the protocol level specified by the level argument, to the value pointed to by the option_value argument for the socket associated with the file descriptor specified by the socket argument.

The level argument specifies the protocol level at which the option resides. To set options at the socket level, specify the level argument as SOL_SOCKET. To set options at other levels, supply the appropriate level identifier for the protocol controlling the option. For example, to indicate that an option is interpreted by the TCP (Transport Control Protocol), set level to IPPROTO_TCP as defined in the <netinet/in.h> header.

The option_name argument specifies a single option to set. The option_name argument and any specified options are passed uninterpreted to the appropriate protocol module for interpretations. The <sys/socket.h> header defines the socket-level options. The options are as follows:

SO_DEBUG
Turns on recording of debugging information. This option enables or disables debugging in the underlying protocol modules. This option takes an int value. This is a Boolean option.
SO_BROADCAST
Permits sending of broadcast messages, if this is supported by the protocol. This option takes an int value. This is a Boolean option.
SO_REUSEADDR
Specifies that the rules used in validating addresses supplied to bind() should allow reuse of local addresses, if this is supported by the protocol. This option takes an int value. This is a Boolean option.
SO_KEEPALIVE
Keeps connections active by enabling the periodic transmission of messages, if this is supported by the protocol. This option takes an int value.
If the connected socket fails to respond to these messages, the connection is broken and threads writing to that socket are notified with a SIGPIPE signal. This is a Boolean option.

SO_LINGER
Lingers on a close() if data is present. This option controls the action taken when unsent messages queue on a socket and close() is performed. If SO_LINGER is set, the system shall block the calling thread during close() until it can transmit the data or until the time expires. If SO_LINGER is not specified, and close() is issued, the system handles the call in a way that allows the calling thread to continue as quickly as possible. This option takes a linger structure, as defined in the <sys/socket.h> header, to specify the state of the option and linger interval.
SO_OOBINLINE
Leaves received out-of-band data (data marked urgent) inline. This option takes an int value. This is a Boolean option.
SO_SNDBUF
Sets send buffer size. This option takes an int value.
SO_RCVBUF
Sets receive buffer size. This option takes an int value.
SO_DONTROUTE
Requests that outgoing messages bypass the standard routing facilities. The destination shall be on a directly-connected network, and messages are directed to the appropriate network interface according to the destination address. The effect, if any, of this option depends on what protocol is in use. This option takes an int value. This is a Boolean option.
SO_RCVLOWAT
Sets the minimum number of bytes to process for socket input operations. The default value for SO_RCVLOWAT is 1. If SO_RCVLOWAT is set to a larger value, blocking receive calls normally wait until they have received the smaller of the low water mark value or the requested amount. (They may return less than the low water mark if an error occurs, a signal is caught, or the type of data next in the receive queue is different from that returned; for example, out-of-band data.) This option takes an int value. Note that not all implementations allow this option to be set.
SO_RCVTIMEO
Sets the timeout value that specifies the maximum amount of time an input function waits until it completes. It accepts a timeval structure with the number of seconds and microseconds specifying the limit on how long to wait for an input operation to complete. If a receive operation has blocked for this much time without receiving additional data, it shall return with a partial count or errno set to [EAGAIN] or [EWOULDBLOCK] if no data is received. The default for this option is zero, which indicates that a receive operation shall not time out. This option takes a timeval structure. Note that not all implementations allow this option to be set.
SO_SNDLOWAT
Sets the minimum number of bytes to process for socket output operations. Non-blocking output operations shall process no data if flow control does not allow the smaller of the send low water mark value or the entire request to be processed. This option takes an int value. Note that not all implementations allow this option to be set.
SO_SNDTIMEO
Sets the timeout value specifying the amount of time that an output function blocks because flow control prevents data from being sent. If a send operation has blocked for this time, it shall return with a partial count or with errno set to [EAGAIN] or [EWOULDBLOCK] if no data is sent. The default for this option is zero, which indicates that a send operation shall not time out. This option stores a timeval structure. Note that not all implementations allow this option to be set.
For Boolean options, 0 indicates that the option is disabled and 1 indicates that the option is enabled.

Options at other protocol levels vary in format and name.

RETURN VALUE

Upon successful completion, setsockopt() shall return 0. Otherwise, -1 shall be returned and errno set to indicate the error.

ERRORS

The setsockopt() function shall fail if:

[EBADF]
The socket argument is not a valid file de
scriptor.
[EDOM]
The send and receive timeout values are too big to fit into the timeout fields in the socket structure.
[EINVAL]
The specified option is invalid at the specified socket level or the socket has been shut down.
[EISCONN]
The socket is already connected, and a specified option cannot be set while the socket is connected.
[ENOPROTOOPT]
The option is not supported by the protocol.
[ENOTSOCK]
The socket argument does not refer to a socket.
The setsockopt() function may fail if:

[ENOMEM]
There was insufficient memory availabl
e for the operation to complete.
[ENOBUFS]
Insufficient resources are available in the system to complete the call.
------------------------------------------------------------------------------------





#define max(a,b) ((a) > (b) ? (a) : (b))



------------------------------------------------------------
四种不同的NAT类型及检测方法 
 
    考 虑到UDP的无状态特性，目前针对其的NAT实现大致可分为Full Cone、Restricted Cone、Port Restricted Cone和Symmetric NAT四种。值得指出的是，对于TCP协议而言，一般来说，目前NAT中针对TCP的实现基本上是一致的，其间并不存在太大差异，这是因为TCP协议本身 便是面向连接的，因此无需考虑网络连接无状态所带来复杂性。 
用语定义

1.内部Tuple：指内部主机的私有地址和端口号所构成的二元组，即内部主机所发送报文的源地址、端口所构成的二元组
2.外部Tuple：指内部Tuple经过NAT的源地址/端口转换之后，所获得的外部地址、端口所构成的二元组，即外部主机收到经NAT转换之后的报文时，它所看到的该报文的源地址（通常是NAT设备的地址）和源端口
3.目标Tuple：指外部主机的地址、端口所构成的二元组，即内部主机所发送报文的目标地址、端口所构成的二元组

详细释义

1. Full Cone NAT：所有来自同一 个内部Tuple X的请求均被NAT转换至同一个外部Tuple Y，而不管这些请求是不是属于同一个应用或者是多个应用的。除此之外，当X-Y的转换关系建立之后，任意外部主机均可随时将Y中的地址和端口作为目标地址 和目标端口，向内部主机发送UDP报文，由于对外部请求的来源无任何限制，因此这种方式虽然足够简单，但却不那么安全

2. Restricted Cone NAT： 它是Full Cone的受限版本：所有来自同一个内部Tuple X的请求均被NAT转换至同一个外部Tuple Y，这与Full Cone相同，但不同的是，只有当内部主机曾经发送过报文给外部主机（假设其IP地址为Z）后，外部主机才能以Y中的信息作为目标地址和目标端口，向内部 主机发送UDP请求报文，这意味着，NAT设备只向内转发（目标地址/端口转换）那些来自于当前已知的外部主机的UDP报文，从而保障了外部请求来源的安 全性

3. Port Restricted Cone NAT：它是Restricted Cone NAT的进一步受限版。只有当内部主机曾经发送过报文给外部主机（假设其IP地址为Z且端口为P）之后，外部主机才能以Y中的信息作为目标地址和目标端 口，向内部主机发送UDP报文，同时，其请求报文的源端口必须为P，这一要求进一步强化了对外部报文请求来源的限制，从而较Restrictd Cone更具安全性

4. Symmetric NAT：这是一种比所有Cone NAT都要更为灵活的转换方式：在Cone NAT中，内部主机的内部Tuple与外部Tuple的转换映射关系是独立于内部主机所发出的UDP报文中的目标地址及端口的，即与目标Tuple无关； 在Symmetric NAT中，目标Tuple则成为了NAT设备建立转换关系的一个重要考量：只有来自于同一个内部Tuple 、且针对同一目标Tuple的请求才被NAT转换至同一个外部Tuple，否则的话，NAT将为之分配一个新的外部Tuple；打个比方，当内部主机以相 同的内部Tuple对2个不同的目标Tuple发送UDP报文时，此时NAT将会为内部主机分配两个不同的外部Tuple，并且建立起两个不同的内、外部 Tuple转换关系。与此同时，只有接收到了内部主机所发送的数据包的外部主机才能向内部主机返回UDP报文，这里对外部返回报文来源的限制是与Port Restricted Cone一致的。不难看出，如果说Full Cone是要求最宽松NAT UDP转换方式，那么，Symmetric NAT则是要求最严格的NAT方式，其不仅体现在转换关系的建立上，而且还体现在对外部报文来源的限制方面。


第二部：NAT类型检测

前提条件:有一个公网的Server并且绑定了两个公网IP(IP-1,IP-2)。这个Server做UDP监听(IP-1,Port-1),(IP-2,Port-2)并根据客户端的要求进行应答。

第一步：检测客户端是否有能力进行UDP通信以及客户端是否位于NAT后？

客户端建立UDP socket然后用这个socket向服务器的(IP-1,Port-1)发送数据包要求服务器返回客户端的IP和Port, 客户端发送请求后立即开始接受数据包，要设定socket Timeout（300ms），防止无限堵塞. 重复这个过程若干次。如果每次都超时，无法接受到服务器的回应，则说明客户端无法进行UDP通信，可能是防火墙或NAT阻止UDP通信，这样的客户端也就 不能P2P了（检测停止）。 
当客户端能够接收到服务器的回应时，需要把服务器返回的客户端（IP,Port）和这个客户端socket的 （LocalIP，LocalPort）比较。如果完全相同则客户端不在NAT后，这样的客户端具有公网IP可以直接监听UDP端口接收数据进行通信（检 测停止）。否则客户端在NAT后要做进一步的NAT类型检测(继续)。

第二步：检测客户端NAT是否是Full Cone NAT？

客户端建立UDP socket然后用这个socket向服务器的(IP-1,Port-1)发送数据包要求服务器用另一对(IP-2,Port-2)响应客户端的请求往回 发一个数据包,客户端发送请求后立即开始接受数据包，要设定socket Timeout（300ms），防止无限堵塞. 重复这个过程若干次。如果每次都超时，无法接受到服务器的回应，则说明客户端的NAT不是一个Full Cone NAT，具体类型有待下一步答UDP包，则说明客户端是一个Full Cone NAT，这样的客户端能够进行UDP-P2P通信（检测停止）。

第三步：检测客户端NAT是否是Symmetric NAT？

客户端建立UDP socket然后用这个socket向服务器的(IP-1,Port-1)发送数据包要求服务器返回客户端的IP和Port, 客户端发送请求后立即开始接受数据包，要设定socket Timeout（300ms），防止无限堵塞. 重复这个过程直到收到回应（一定能够收到，因为第一步保证了这个客户端可以进行UDP通信）。 
用同样的方法用一个socket向服务器的(IP-2,Port-2)发送数据包要求服务器返回客户端的IP和Port。 
比 较上面两个过程从服务器返回的客户端(IP,Port),如果两个过程返回的(IP,Port)有一对不同则说明客户端为Symmetric NAT，这样的客户端无法进行UDP-P2P通信（检测停止）。否则是Restricted Cone NAT，是否为Port Restricted Cone NAT有待检测(继续)。

第四步：检测客户端NAT是否是Restricted Cone NAT还是Port Restricted Cone NAT？

客户端建立UDP socket然后用这个socket向服务器的(IP-1,Port-1)发送数据包要求服务器用IP-1和一个不同于Port-1的端口发送一个UDP 数据包响应客户端, 客户端发送请求后立即开始接受数据包，要设定socket Timeout（300ms），防止无限堵塞. 重复这个过程若干次。如果每次都超时，无法接受到服务器的回应，则说明客户端是一个Port Restricted Cone NAT，如果能够收到服务器的响应则说明客户端是一个Restricted Cone NAT。以上两种NAT都可以进行UDP-P2P通信。
---------------------------------
 



find . -name .svn | xargs rm -r
