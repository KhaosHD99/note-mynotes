1 局部变量能否和全局变量重名？ 
  答：能，局部会屏蔽全局。要用全局变量，需要使用"::" 

2 如何引用一个已经定义过的全局变量？ 
  答：extern 

3 指针变量的加减运算只能对数组指针变量进行， 对指向其它类型变量的指针变量作加减运算是毫无意    义的
4 a可以认为它等价于数组的首地址
  char* b=a的意思是指针b存储的就是数组a的首地址
  而cout<<流操作实际上从它后面的对象得到一个地址，再根据地址指向的存储区域得到数据并输出
  所以cout<<b 输出的是指针b指向的"hello!"字符串
  和cout<<a的输出结果是一样的
  cout<<&a输出的就是"hello!"的第一个字符h的地址
  cout<<&b输出指针b的地址，而不是b存储的地址
  如果将b指向一个非字符串局部变量，比如整形变量，cout<<b将输出b存储的地址，这可能是流操作本  身的机制造成的
  字符串存储在文字常量区，它的地址是不变的且程序运行期间一直存在
  而局部变量存储在栈区，每次调用函数都会在栈区为它分配一个存储空间，所以它的地址并不是固定的
  也许这就是为什么流操作符输出一个指向字符串的指针和输出变量的指针一个是值一个是地址的原因吧 
5 指针所指向的值的互换，最好用不要用指针做过渡变量
6 1)C++无法知道指针所指对象的大小，指针的大小永远为4字节
  2)在函数中，数组参数退化为指针
    void fun(char  a[1000])
    {
       cout<<sizeof(a)<<endl;  //输出4而不是1000
    }

  
  通过malloc分配内存后，sizeof(p)取得的是指针变量本身所占的空间大小
7 sizeof()把'\0'计算在内
  strlen()反之
8 *p++是*(p++)
9 while(*p++)判断指针所指向的内存块是否有值，即使
10 数组名指针不能进行指针算术运算
11 指针 \0
12 外部函数
12 malloc()分配不足 捕捉异常
13 会补成是最大数据的倍数
14 指针作为函数的参数传递时，编译器会复制一份副本传递过去，所以这个时候，不要指望用该指针去   申请动态内存
15 一般函数是编译时在内存中为它单独开辟一段空间的，它的“首地址”叫入口地址，函数体的代码都     在里面。另外一些形参和局部变量建立在一个叫“栈”的内存区。栈的特性是先进后出。
   当程序运行到调用函数的地方，比如main函数中有一处函数调用a=printf(…),首先把main里面当前这    段代码的物理地址保存起来，放到为printf()准备的栈里面去，叫做“函数调用现场保护”。然后系   统找到   内存中printf()的入口地址，把实参的值按顺序传进来一一放到指定的位置上（形参的排列   是有一定   规律   的）。此后系统就离开main，而开始去执行printf()去啦，也就是你说的“控制   转移”。
   当printf()函数执行完，返回的时候开始把栈里面的内容依次取出来，别忘了他是先进后出的，也就     是说   最后取到原来的那个物理地址，于是系统又回到main的那个地方，然后把最近取出来的另一个   变量的   值送   回到main的位置，比如这里由a接收。同时把为printf()建立的栈销毁掉，printf()   的那些形参和局部   变   量就统统寿终正寝了。一个函数最多只能返回一个值，因为更早取出来的   值都被抛弃掉啦。
   这种函数调用，因为要建栈、保护调用现场，转移物理地址，执行完了后还要再出栈、返回地址、返     回局   部变量值，挺耗时间的。 

   补充：程序运行期间所有函数的栈是使用一段空间的，用"栈顶"和"栈底"为每个函数标记自己的栈。     新进   栈的数据都放在栈顶，出栈的也是从栈顶开始出。而当栈顶和栈底重合，这个栈差不多可以销   毁它了  （把   栈顶和栈底标记改掉，没法找到它了，也就算销毁了），不过我在数据结构里面和汇   编学的栈略有不   同。
   今天看了一下VC++6.0编译出来的汇编码，它编译出来的程序大致是这样运行的：
   调用一个普通的函数时，系统会把原来为main()所建栈的栈底地址进到栈里，以便返回时恢复main()     的栈   ，接着把调用函数的实参进到栈里，把当前正在运行位置的物理地址（代码区的）也进到栈里   ，然后   转到   被调用函数的入口地址。这时的栈还暂时属于main()的。但马上会把这个栈顶提升   为栈底（新栈底正   好是   刚才存放main栈顶地址的那个内存单元），新的栈只能向上发展，就把   原来属于main的栈给屏蔽掉了   。关   于实参和形参结合的过程，我认为前面实参的进栈就是了，   实参在栈中所占的内存单元就是形参的地   址，   函数中需要操作形参就直接去栈里面找到它们。
  （PS:个别地方和我接触过的“标准”上说的有些矛盾，尤其是形参在栈底下面，是VC++的编译器对程     序   作了优化，减少了不必要的空间开销吗？也可能是我对栈的定义理解不是很准确，请见谅。）

   当函数全部语句执行完要返回时，严格遵循相反的步骤，把栈顶调回栈底，再向下把刚才保存的那个     main   的栈底地址取出来恢复为栈底，这时候栈的形态已经恢复为原来main的了，然后栈顶继续下降   ，就把   调用   现场的物理地址也取出来了，根据这个地址，流程回到了main中发生本次调用的地   方（位于代码区）   。如果return语句返回的是一个数而不是变量名字，则这个数据不保存在内存中   ，而是保存在CPU的寄存器里面。系统去指定的位置把返回值取出来送给左侧接受它的变量，然后把栈   顶恢复到函数调用前的位置，继续向后运行。

   关于static关键字，它修饰变量的时候，系统会把这些变量放到内存中的静态存储区，而不是栈区。   静态存储区的单元一旦分配了，在程序结束前就不会被释放，也就谈不上再重新分配给其他的变量了   。但是楼主说的用来修饰函数，我感觉在VC++6.0下好像没有引起任何变化。严格说来被调用函数结束   后它在栈中的数据还继续存在着，但是系统不再访问它们了，其实我觉得也可以访问，但是编译器不   肯去为我们做而已。而且如果后面再发生一次函数调用，新的栈会紧挨着main生长，原来留下的那些   数据就给覆盖掉了。

   哦，我在我的机子上还发现了一个有趣的现象，函数的栈建立起来后，在正式开始执行函数的代码前   编译器会用一个奇怪的数据0x0cccccccch来初始化所有的栈单元（32位机下4个字节为一组），不知道   为什么这样做。如果程序中定义自动变量没有初始化，就会导致它们具有不可预料的值,但在VC++6.0   下这样是可以预料它们的值的。楼主如果有兴趣可以把下面这段代码放到任意一个函数里试试
   `long a,b;if(a==b) printf("a=%ld,b=%ld",a,b); 
16 gcc 编译器对<stdlib>,<iostream>,no such file
17 用gcc编译的时候要加上-g参数，才能用gdb的list功能
18 
   Andre wrote:

   > Hi all,
   > 
   > Can someone point out what is wrong with this tiny piece of code? I'm
   > compiling it with "g++ ./Main.cpp", and get the error message "error:
   > request for member 'konnect' in 'theSocket', which is of non-class
   > type 'Socket ()()'"

   The error message is surprisingly accurate.

   > Thanks in advance,
   > 
   > Andre
   > #####################################
   > class Socket
   > {
   > public:
   > void konnect(){};
   > };
   > 
   > int main(int argc, char ** argv)
   > {
   > Socket theSocket();

   This declares theSocket as an uninitialized variable of function type:

   Socket () ( void )


   You might want to say

   Socket theSocket;

   instead.

   > 
   > theSocket.konnect();

   A function has no members.

   > 
   > return 0;
   > }
   > #####################################


   Best

   Kai-Uwe Bux
19 class CTest
   {
   };
20 gcc -I
  

  
  