1 局部变量能否和全局变量重名？ 
  答：能，局部会屏蔽全局。要用全局变量，需要使用"::" 

2 如何引用一个已经定义过的全局变量？ 
  答：extern 

3 指针变量的加减运算只能对数组指针变量进行， 对指向其它类型变量的指针变量作加减运算是毫无意    义的
4 a可以认为它等价于数组的首地址
  char* b=a的意思是指针b存储的就是数组a的首地址
  而cout<<流操作实际上从它后面的对象得到一个地址，再根据地址指向的存储区域得到数据并输出
  所以cout<<b 输出的是指针b指向的"hello!"字符串
  和cout<<a的输出结果是一样的
  cout<<&a输出的就是"hello!"的第一个字符h的地址
  cout<<&b输出指针b的地址，而不是b存储的地址
  如果将b指向一个非字符串局部变量，比如整形变量，cout<<b将输出b存储的地址，这可能是流操作本  身的机制造成的
  字符串存储在文字常量区，它的地址是不变的且程序运行期间一直存在
  而局部变量存储在栈区，每次调用函数都会在栈区为它分配一个存储空间，所以它的地址并不是固定的
  也许这就是为什么流操作符输出一个指向字符串的指针和输出变量的指针一个是值一个是地址的原因吧 
5 指针所指向的值的互换，最好用不要用指针做过渡变量
6 1)C++无法知道指针所指对象的大小，指针的大小永远为4字节
  2)在函数中，数组参数退化为指针
    void fun(char  a[1000])
    {
       cout<<sizeof(a)<<endl;  //输出4而不是1000
    }

  
  通过malloc分配内存后，sizeof(p)取得的是指针变量本身所占的空间大小
7 sizeof()把'\0'计算在内
  strlen()反之
8 *p++是*(p++)
9 while(*p++)判断指针所指向的内存块是否有值，即使
10 数组名指针不能进行指针算术运算
11 指针 \0
12 外部函数
12 malloc()分配不足 捕捉异常
13 会补成是最大数据的倍数
14 指针作为函数的参数传递时，编译器会复制一份副本传递过去，所以这个时候，不要指望用该指针去   申请动态内存
15 一般函数是编译时在内存中为它单独开辟一段空间的，它的“首地址”叫入口地址，函数体的代码都     在里面。另外一些形参和局部变量建立在一个叫“栈”的内存区。栈的特性是先进后出。
   当程序运行到调用函数的地方，比如main函数中有一处函数调用a=printf(…),首先把main里面当前这    段代码的物理地址保存起来，放到为printf()准备的栈里面去，叫做“函数调用现场保护”。然后系   统找到   内存中printf()的入口地址，把实参的值按顺序传进来一一放到指定的位置上（形参的排列   是有一定   规律   的）。此后系统就离开main，而开始去执行printf()去啦，也就是你说的“控制   转移”。
   当printf()函数执行完，返回的时候开始把栈里面的内容依次取出来，别忘了他是先进后出的，也就     是说   最后取到原来的那个物理地址，于是系统又回到main的那个地方，然后把最近取出来的另一个   变量的   值送   回到main的位置，比如这里由a接收。同时把为printf()建立的栈销毁掉，printf()   的那些形参和局部   变   量就统统寿终正寝了。一个函数最多只能返回一个值，因为更早取出来的   值都被抛弃掉啦。
   这种函数调用，因为要建栈、保护调用现场，转移物理地址，执行完了后还要再出栈、返回地址、返     回局   部变量值，挺耗时间的。 

   补充：程序运行期间所有函数的栈是使用一段空间的，用"栈顶"和"栈底"为每个函数标记自己的栈。     新进   栈的数据都放在栈顶，出栈的也是从栈顶开始出。而当栈顶和栈底重合，这个栈差不多可以销   毁它了  （把   栈顶和栈底标记改掉，没法找到它了，也就算销毁了），不过我在数据结构里面和汇   编学的栈略有不   同。
   今天看了一下VC++6.0编译出来的汇编码，它编译出来的程序大致是这样运行的：
   调用一个普通的函数时，系统会把原来为main()所建栈的栈底地址进到栈里，以便返回时恢复main()     的栈   ，接着把调用函数的实参进到栈里，把当前正在运行位置的物理地址（代码区的）也进到栈里   ，然后   转到   被调用函数的入口地址。这时的栈还暂时属于main()的。但马上会把这个栈顶提升   为栈底（新栈底正   好是   刚才存放main栈顶地址的那个内存单元），新的栈只能向上发展，就把   原来属于main的栈给屏蔽掉了   。关   于实参和形参结合的过程，我认为前面实参的进栈就是了，   实参在栈中所占的内存单元就是形参的地   址，   函数中需要操作形参就直接去栈里面找到它们。
  （PS:个别地方和我接触过的“标准”上说的有些矛盾，尤其是形参在栈底下面，是VC++的编译器对程     序   作了优化，减少了不必要的空间开销吗？也可能是我对栈的定义理解不是很准确，请见谅。）

   当函数全部语句执行完要返回时，严格遵循相反的步骤，把栈顶调回栈底，再向下把刚才保存的那个     main   的栈底地址取出来恢复为栈底，这时候栈的形态已经恢复为原来main的了，然后栈顶继续下降   ，就把   调用   现场的物理地址也取出来了，根据这个地址，流程回到了main中发生本次调用的地   方（位于代码区）   。如果return语句返回的是一个数而不是变量名字，则这个数据不保存在内存中   ，而是保存在CPU的寄存器里面。系统去指定的位置把返回值取出来送给左侧接受它的变量，然后把栈   顶恢复到函数调用前的位置，继续向后运行。

   关于static关键字，它修饰变量的时候，系统会把这些变量放到内存中的静态存储区，而不是栈区。   静态存储区的单元一旦分配了，在程序结束前就不会被释放，也就谈不上再重新分配给其他的变量了   。但是楼主说的用来修饰函数，我感觉在VC++6.0下好像没有引起任何变化。严格说来被调用函数结束   后它在栈中的数据还继续存在着，但是系统不再访问它们了，其实我觉得也可以访问，但是编译器不   肯去为我们做而已。而且如果后面再发生一次函数调用，新的栈会紧挨着main生长，原来留下的那些   数据就给覆盖掉了。

   哦，我在我的机子上还发现了一个有趣的现象，函数的栈建立起来后，在正式开始执行函数的代码前   编译器会用一个奇怪的数据0x0cccccccch来初始化所有的栈单元（32位机下4个字节为一组），不知道   为什么这样做。如果程序中定义自动变量没有初始化，就会导致它们具有不可预料的值,但在VC++6.0   下这样是可以预料它们的值的。楼主如果有兴趣可以把下面这段代码放到任意一个函数里试试
   `long a,b;if(a==b) printf("a=%ld,b=%ld",a,b); 
16 gcc 编译器对<stdlib>,<iostream>,no such file
17 用gcc编译的时候要加上-g参数，才能用gdb的list功能
18 
   Andre wrote:

   > Hi all,
   > 
   > Can someone point out what is wrong with this tiny piece of code? I'm
   > compiling it with "g++ ./Main.cpp", and get the error message "error:
   > request for member 'konnect' in 'theSocket', which is of non-class
   > type 'Socket ()()'"

   The error message is surprisingly accurate.

   > Thanks in advance,
   > 
   > Andre
   > #####################################
   > class Socket
   > {
   > public:
   > void konnect(){};
   > };
   > 
   > int main(int argc, char ** argv)
   > {
   > Socket theSocket();

   This declares theSocket as an uninitialized variable of function type:

   Socket () ( void )


   You might want to say

   Socket theSocket;

   instead.

   > 
   > theSocket.konnect();

   A function has no members.

   > 
   > return 0;
   > }
   > #####################################


   Best

   Kai-Uwe Bux
19 class CTest
   {
   };
20 gcc -I
21 返回值 生存期
22 #ifdef __cplusplus extern "C" { #endif 的解释 (2009-04-25 22:26:06)转载
标签：c语言杂谈	
 
时常在cpp的代码之中看到这样的代码:
#ifdef __cplusplus
extern "C" {
#endif
//一段代码
#ifdef __cplusplus
}
#endif
　　
    这样的代码到底是什么意思呢？首先，__cplusplus是cpp中的自定义宏，那么定义了这个宏的话表示这是一段cpp的代码，也就是说，上面的代码的含义是:如果这是一段cpp的代码，那么加入extern "C"{和}处理其中的代码。
　　要明白为何使用extern "C"，还得从cpp中对函数的重载处理开始说起。在c++中，为了支持重载机制，在编译生成的汇编码中，要对函数的名字进行一些处理，加入比如函数的返回类型等等.而在C中，只是简单的函数名字而已，不会加入其他的信息.也就是说:C++和C对产生的函数名字的处理是不一样的. 目的就是主要实现C与C++的相互调用问题。
 
c.h的实现
#ifndef _c_h_
#define _c_h_
#ifdef __cplusplus
extern "C" {
#endif
void C_fun();
#ifdef __cplusplus
}
#endif
#endif
-----------------------------------
c.c的实现
＃include "c.h"
void C_fun()
{
}
------------------------------------
在cpp.cpp中调用c.c中的C_test()
cpp.cpp的实现
＃include "c.h"
int main()
{
     C_fun()
}
其中__cplusplus是C++编译器的保留宏定义．就是说C++编译器认为这个宏已经定义了．
所以关键是extern "C" {}
extern "C"是告诉Ｃ＋＋编译器件括号里的东东是按照C的obj文件格式编译的，要连接的话按照C的命名规则去找．
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
那么C中是如何调用C++中的函数cpp_fun()呢？
因为先有C后有C++, 所以只能从C++的代码中考虑了．
加入C++中的函数或变量有可能被Ｃ中的文件掉用，则应该这样写，也是用extern "C"{}
不过是代码中要加，头文件也要加，因为可能是C++中也调用
--------------------------------------
cpp.h的实现
#ifndef _c_h_
#define _c_h_
#ifdef __cplusplus
extern "C" {
#endif
void CPP_fun();
#ifdef __cplusplus
}
#endif
#endif 
.-------------------------------------------
Cpp.cpp的实现
extern "C" {    //告诉C+++编译器,扩号里按照C的命名规则编译
void CPP_fun()
{
     .....
}
 
 
总结
　　C和C++对函数的处理方式是不同的.extern "C"是使C++能够调用C写作的库文件的一个手段，如果要对编译器提示使用C的方式来处理函数的话，那么就要使用extern "C"来说明。
  
23 makefile.am for .so
   LDFLAGS=-fPIC -shared
   moduledir=$(prefix)/lib
   module_PROGRAMS=CProdCons.so
   CProdCons_so_SOURCES=CProdCons.cpp
   CProdCons_so_LDFLAGS=-module
   INCLUDES=-I../include
24 makefile.am for .a
   noinst_LIBRARIES=libCProdCons.a
   libCProdCons_a_SOURCES = CProdCons.cpp
   INCLUDES=-I../include
25 const char* 赋值给 char*
26 当一个char字符的地址赋给指针后，要加\0才是字符串
27 拷贝一份字符串来做strtok操作避免原来的受到更改
28 int a[10] = {0};   或者   char a[10] = {0};   //将数组每一项初始化为0
29 '\0'的数值就是0
30 当指针作为参数传入函数，只能修改指针所指向的内容，分配空间和赋值都是不行的
31 多个头文件的的防止重复引用的语句也要防止重复
32 memcpy(),menset()很有用
33 尽量不用cint，cout

10.22 1)sprintf() snprintf() sscanf()very useful 
      2)int tm_sec 代表目前秒数，正常范围为0-59，但允许至61秒 
        int tm_min 代表目前分数，范围0-59 
        int tm_hour 从午夜算起的时数，范围为0-23 
        int tm_mday 目前月份的日数，范围01-31 
        int tm_mon 代表目前月份，从一月算起，范围从0-11 
        int tm_year 从1900 年算起至今的年数 
        int tm_wday 一星期的日数，从星期一算起，范围为0-6 
        int tm_yday 从今年1月1日算起至今的天数，范围为0-365 
        int tm_isdst 日光节约时间的旗标 

10.27 如果枚举没有初始化, 即省掉"=整型常数"时, 则从第一个标识符开始, 顺 　　次赋给标识符0,       1, 2, ...。但当枚举中的某个成员赋值后, 其后的成员按依次 　　加1的规则确定其值

11.07 while(item->phones[phone_count].szphone[0] != '\0')
      {
		phone_count++;
		if(phone_count == MAX_PHONE_COUNT)
      		break;
      }
      
      __LINE__, __FILE__ ##__VA_ARGS__ very useful

11.09 function daclare: args can add daype prefix     

11.17 sprintf(str, "%i", index);
      str 用字符数组

11.18 实例化一个类， 如果申请动态内存，要手动释放（new)
      如果采用值类型的方法实例化类，就自动释放资源

11.19 	━━━━━━━━━━━━━━━━━━━━━━━━
        符号                  作用 
      	────────────────────────
  	 %d              十进制有符号整数 
         %ld
   	 %u              十进制无符号整数 
   	 %f              浮点数 
    	 %s              字符串 
   	 %c              单个字符 
  	 %p              指针的值 
   	 %e              指数形式的浮点数 
   	 %x, %X          无符号以十六进制表示的整数 
  	 %0              无符号以八进制表示的整数 
   	 %g              自动选择合适的表示法 
	━━━━━━━━━━━━━━━━━━━━━━━━

      