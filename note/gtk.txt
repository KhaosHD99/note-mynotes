1 g_object_unref ()
  void                g_object_unref                      (gpointer object);Decreases the reference count of object.   When its reference count drops to 0, the object is finalized (i.e. its memory is freed). 

//gdk_display_warp_pointer(display, screen, x + 12, y + 12); 



guint keyval = GDK_Tab;
	GdkKeymapKey* keys;
	gint n_keys;
	GdkEvent* gdk_event = gdk_event_new(GDK_KEY_PRESS);
	    	
			((GdkEventKey*)gdk_event)->window = fixed->window;
		    ((GdkEventKey*)gdk_event)->send_event = TRUE;
		    ((GdkEventKey*)gdk_event)->time = GDK_CURRENT_TIME;
		    ((GdkEventKey*)gdk_event)->state = GDK_KEY_PRESS_MASK;
		    ((GdkEventKey*)gdk_event)->keyval = GDK_3270_BackTab;
			gdk_event_put(gdk_event);

gdk_window_get_origin
char varray +=

g_object_set(web_view,
 	     "full-content-zoom", TRUE,					
             NULL);

#define _(STRING) g_convert(STRING, -1, "UTF-8", "GB2312", NULL, NULL, NULL)	

typedef enum {
    WEBKIT_NAVIGATION_RESPONSE_ACCEPT,
    WEBKIT_NAVIGATION_RESPONSE_IGNORE,
    WEBKIT_NAVIGATION_RESPONSE_DOWNLOAD
} WebKitNavigationResponse;


0527 
     
     F3:  ffc0
     
     F5:  ffc2
     F6:  ffc3
     F7:  ffc4
     F8:  ffc5
     F9:  ffc6
     F10: ffc7
     F11: ffc8
     F12: ffc9
          1008ff81

     fn + left:   1008ff11
     fn + right:  1008ff13 
          up:     1008ff02
          donw:   1008ff03
     
WEBKIT_WEB_VIEW		
  gtk_widget_get_parent
     gtk_p	rogress_bar_set_text 

 
gtk_label_set_line_wrap ()
void                gtk_label_set_line_wrap             (GtkLabel *label,
                                                         gboolean wrap);
Toggles line wrapping within the GtkLabel widget. TRUE makes it break lines if text exceeds the widget's size. FALSE lets the text get cut off by the edge of the widget if it exceeds the widget size. 

Note that setting line wrapping to TRUE does not make the label wrap at its parent container's width, because GTK+ widgets conceptually can't make their requisition depend on the parent container's size. For a label that wraps at a specific position, set the label's width using gtk_widget_set_size_request().








On lun, 2005-01-17 at 10:24 +0100, Andreas Madsack wrote:
> I can hide them with gtk_widget_hide(..), but how can I get the pointer?
> Hiding is nice, but delete an element would be perfect.
This is a list of all children of the menu:
GTK_MENU_SHELL(menu)->children

It is read-only, so you're only allowed to hide the widget and not
remove to it.


gdk_window_get_origin(eventbox_home->window, &x, &y);



GDK_INTERP_NEAREST Nearest neighbor sampling; this is the fastest and lowest quality mode. Quality is normally unacceptable when scaling down, but may be OK when scaling up.  
GDK_INTERP_TILES This is an accurate simulation of the PostScript image operator without any interpolation enabled. Each pixel is rendered as a tiny parallelogram of solid color, the edges of which are implemented with antialiasing. It resembles nearest neighbor for enlargement, and bilinear for reduction.  
GDK_INTERP_BILINEAR Best quality/speed balance; use this mode by default. Bilinear interpolation. For enlargement, it is equivalent to point-sampling the ideal bilinear-interpolated image. For reduction, it is equivalent to laying down small tiles and integrating over the coverage area.  
GDK_INTERP_HYPER This is the slowest and highest quality reconstruction function. It is derived from the hyperbolic filters in Wolberg's "Digital Image Warping", and is formally defined as the hyperbolic-filter sampling the ideal hyperbolic-filter interpolated image (the filter is designed to be idempotent for 1:1 pixel mapping).  


scaled_pixbuf = gdk_pixbuf_scale_simple(pixbuf,
											 width,
											 height,
											 GDK_INTERP_NEAREST);









#if 1
gboolean set_background_pixmap(const gchar *filename, GtkWidget *widget, int width, int height)
{	
	GdkPixbuf *scaled_pixbuf = NULL;
	GdkPixbuf *pbuf = NULL;
	GdkPixmap *pixmap = NULL;
	GdkBitmap *bitmap = NULL;
	
	gint img_width, img_height;

	if(GTK_WIDGET_NO_WINDOW(widget))
	{	
		printf("**************** The widget has not window !\n");   
		return FALSE; 
	}
	
	if(!GTK_WIDGET_REALIZED(widget))
	{
		gtk_widget_realize(widget);
	}

	if(!filename)
	{	
		gdk_window_set_back_pixmap(widget->window, NULL, FALSE);
		printf("filename NULL ! \n");  
		return FALSE;
	}	
	
	pbuf = gdk_pixbuf_new_from_file(filename, NULL);
	if(!pbuf)
	{
		printf("gdk_pixbuf_new_from_file failed ! \n");  
		return FALSE;
	}
	img_width = gdk_pixbuf_get_width(pbuf);
	img_height = gdk_pixbuf_get_height(pbuf);
	//showDebug("img_width : %d, ------- img_height : %d \n", img_width, img_height);
	
	gint drawable_width, drawable_height;
	if(width<=0 || height<=0)
	{
		gdk_drawable_get_size(widget->window, &drawable_width, &drawable_height);
		//showDebug("drawable_width : %d, ------- drawable_height : %d \n", drawable_width, drawable_height);	
	}
	else
	{
		drawable_width = width;
		drawable_height = height;
		//showDebug("width : %d, ------- height : %d \n", width, height);	
	}
	
	double scale_x, scale_y;
	if(img_width>0 && img_height>0)
	{
		scale_x = (double)drawable_width/img_width;
		scale_y = (double)drawable_height/img_height;
	}
	else
	{
		scale_x = 1.0;
		scale_y = 1.0;
	}	
	//showDebug("scale_x : %f, ------- scale_y : %f \n", scale_x, scale_y);	
	
	scaled_pixbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB, 
						TRUE,
	       				gdk_pixbuf_get_bits_per_sample(pbuf), 
	       				drawable_width, 
	       				drawable_height);
	gdk_pixbuf_fill(scaled_pixbuf, 0);
	gdk_pixbuf_composite(pbuf, scaled_pixbuf,
						 0, 0,
						 drawable_width, drawable_height, 
						 0, 0,
						 scale_x, scale_y,
						 GDK_INTERP_BILINEAR, 0xFF);
	pixmap = gdk_pixmap_new(widget->window, drawable_width, drawable_height, -1);
	gdk_draw_pixbuf(pixmap, NULL, scaled_pixbuf, 0, 0, 0, 0, -1, -1, GDK_RGB_DITHER_NORMAL, 1, 1);
	
	gdk_draw_drawable(widget->window, 
					  widget->style->fg_gc[GTK_WIDGET_STATE(widget)],
					  pixmap,
					  0, 0,
					  0, 0,
					  drawable_width, drawable_height);

	gtk_widget_set_app_paintable(widget, TRUE);
	gdk_pixbuf_render_pixmap_and_mask(scaled_pixbuf, &pixmap, &bitmap, 128);
	gtk_widget_shape_combine_mask(widget, bitmap, 0, 0);
	gdk_window_set_back_pixmap(widget->window, pixmap, FALSE);
	gtk_widget_queue_draw(widget);

	if(scaled_pixbuf)
	{
		gdk_pixbuf_unref(scaled_pixbuf);
		scaled_pixbuf = NULL;
	}
	if(pbuf)
	{	
		gdk_pixbuf_unref(pbuf);
		pbuf = NULL;
	}	
	if(pixmap)
	{	
		gdk_pixmap_unref(pixmap);
		pixmap = NULL;
	}	
	if(bitmap)
	{
		gdk_bitmap_unref(bitmap);
		bitmap = NULL;
	}
	
	return TRUE;
}
#endif
