
@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WorldView(Strategy guiding thoughts) @@@@@@@@@@@@@@@@@@@@@@@@@@
1 more rumination, more communication(internet, tradition), sum up experience --------- ponder more
2 perpetual learning, always be ready					      ----------learn more
   

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


%%%%%%%%%%%%%%%%%%%%%%%%%%%% Life arch %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
1 i feel idle, i can
1) reading, writing(diary or handwriting practise) or listening(english)
2) (opensource prj)
3) [communication], just outdoor activities, network communities(specially the foreign    webside)

2 regular sport, sleep and get up early

4 train my interest(swim, high quality music, camping)



Alternative Option:
i need favor fews 'en' website instead domestic's					***
   high quality music ???

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



/********************************** career Patterns ***********************************
Software idealized target:
1) availability(correctness)
2) stablity(robustness)
 ----- high user experience(simple to use, ...)------  
3) flexibility
4) high efficiency
5) low resource occupation(cpu, memory)
6) scalability



Concrete measures:
1) Read constantly(the classic)
2) breakable toy(use open source, )
3) 记录工作日志, 开发日志
4) 



Coding moto:
2) 高效(精神状态好, [一心一意]，直奔要害, [不要纠缠]，良好的编码习惯，[交流]，满溢法，适当多线程法)
3)【严谨】不要侥幸!!!
4) [flexibility] configurable
5) scalability  扩展和维护
6) 注析，【日志】










   



 


************************************************************************************/

1 通常自己觉得很诡异，很不可思议的问题，都是自己的问题------无论如何自己先做到最好




有一种xx叫xx
就像xx xxx



A字头
AE-阿联酋(UNITED EMIRATES) 
AF-阿富汗(AFGHANISTAN) 
AL-阿尔巴尼亚(ALBANIA) 
AM-亚美尼亚(ARMENIA) 
AO-安哥拉(ANGOLA) 
AR-阿根廷(ARGENTINA) 
AT-奥地利(AUSTRIA) 
AU-澳大利亚(AUSTRALIA) 
AZ-阿塞拜疆(AZERBAIJAN(REPUBLIC)) 

B字头
BD-孟加拉(BANGLADESH) 
BE-比利时(BELGIUM) 
BF-布基纳法索(BURKINA FASO) 
BG-保加利亚(BULGARIA) 
BH-巴林(BAHREIN) 
BI-布隆迪(BURUNDI) 
BJ-贝宁(BENIN) 
BL-巴勒斯坦() 
BN-文莱(BRUNEI DARUSSALAM) 
BO-玻利维亚(BOLIVIA) 
BR-巴西(BRAZIL) 
BW-博茨瓦纳(BOTSWANA) 
BY-白俄罗斯(BYELORUSSIA) 

C字头
CA-加拿大(CANADA) 
CF-中非(CENTRAL AFRICA) 
CG-刚果(CONGO) 
CH-瑞士(SWITZERLAND) 
CL-智利(CHILE) 
CM-喀麦隆(CAMEROON) 
CN-中国(CHINA) 
CO-哥伦比亚(COLOMBIA) 
CR-哥斯达黎加(COSTA RICA) 
CS-捷克(CZECH REPUBIC) 
CU-古巴(CUBA) 
CY-塞浦路斯(CYPRUS) 

D字头
DE-德 国(GERMANY) 
DK-丹麦(DENMARK) 
DO-多米尼加共和国(DOMINICAN REPUBLIC) 
DZ-阿尔及利亚(ALGERIA) 

E字头
EC-厄瓜多尔(ECUADOR) 
EE-爱沙尼亚(ESTONIA) 
EG-埃及(EGYPT) 
ES-西班牙(SPAIN) 
ET-埃塞俄比亚(ETHIOPIA) 

F字头
FI-芬兰(FINLAND) 
FJ-斐济(FIJI) 
FR-法国(FRANCE) 

G字头
GA-加蓬(GABON) 
GB-英国(UNITED KINGDOM) 
GD-格林纳达(GRENADA) 
GE-格鲁吉亚(GEORGIA) 
GH-加纳(GHANA) 
GN-几内亚(GUINEA) 
GR-希腊(GREECE) 
GT-危地马拉(GUATEMALA) 

H字头
HK-香港特别行政区(HONG KONG) 
HN-洪都拉斯(HONDURAS) 
HU-匈牙利(HUNGARY)   

I字头
ID-印度尼西亚(INDONESIA) 
IE-爱尔兰(IRELAND) 
IL-以色列(ISRAEL) 
IN-印度(INDIA) 
IQ-伊拉克(IRAQ) 
IR-伊朗(IRAN) 
IS-冰岛(ICELAND) 
IT-意大利(ITALY) 

J字头
JM-牙买加(JAMAICA) 
JO-约旦(JORDAN) 
JP-日本(JAPAN) 

K字头
KG-吉尔吉斯坦(KYRGYZSTAN) 
KH-柬埔寨(KAMPUCHEA(CAMBODIA)) 
KP-北朝鲜(KOREA,DEM.PEOPLE’S) 
KR-韩国(REPUBLIC OF KOREA) 
KT-科特迪瓦共和国(COTE O’IVOIRE) 
KW-科威特(KUWATI) 
KZ-哈萨克(KAZAKHSTAN) 

L 字头
LA-老挝(LAOS) 
LB-黎巴嫩(LEBANON) 
LC-圣卢西亚(SAINT LUEIA) 
LI-列支敦士登(LIECHTENSTEIN) 
LK-斯里兰卡(SRI LANKA) 
LR-利比里亚(LIBERIA) 
LT-立陶宛(LITHUANIA) 
LU-卢森堡(LUXEMBOURG) 
LV-拉脱维亚(LATVIA) 
LY-利比亚(LIBYAN) 

M字头
MA-摩洛哥(MOROCCO) 
MC-摩纳哥(MONACO) 
MD-摩尔多瓦(MOLDOVA,REPUBLIC OF) 
MG-马达加斯加(MADAGASCAR) 
ML-马里(MALI) 
MM-缅甸(BURMA(MYANMAR)) 
MN-蒙古(MONGOLIA) 
MO-澳门地区(MACAU) 
MT-马耳他(MALTA) 
MU-毛里求斯(MAURITIUS) 
MW-马拉维(MALAWI) 
MX-墨西哥(MEXICO) 
MY-马来西亚(MALAYSIA) 
MZ-莫桑比克(MOZAMBIQUE) 

N字头
NA-纳米比亚(NAMIBIA) 
NE-尼日尔(NIGER) 
NG-尼日利亚(NIGERIA) 
NI-尼加拉瓜(NICARAGUA) 
NL-荷兰(NETHERLANDS) 
NO-挪威(NORWAY) 
NP-尼泊尔(NEPAL) 
NZ-新西兰(NEW ZEALAND) 

O字头
OM-阿曼(OMAN) 

P字头
PA-巴拿马(PANAMA) 
PE-秘鲁(PERU) 
PG-巴布亚新几内亚(PAPUA NEW GUINEA) 
PH-菲律宾(PHILIPPINES) 
PK-巴基斯坦(PAKISTAN) 
PL-波兰(POLAND) 
PT-葡萄牙(PORTUGAL) 
PY-巴拉圭(PARAGUAY) 

Q字头
QA-卡塔尔(QATAR) 

R
RO-罗马尼亚(ROMANIA) 
RU-俄罗斯(RUSSIAN FEDERATION) 

S字头
SA-沙特阿拉伯(SAUDI ARABIA) 
SC-塞舌尔(SEYCHELLES) 
SD-苏丹(SUDAN) 
SE-瑞典(SWEDEN) 
SG-新加坡(SINGAPORE) 
SI-斯洛文尼亚(SLOVENIA) 
SK-斯洛伐克(SLOVAKIA) 
SM-圣马力诺(SAN MARINO) 
SN-塞内加尔(SENEGAL) 
SO-索马里(SOMALIA) 
SY-叙利亚(SYRIA) 
SZ-斯威士兰(SWAZILAND) 

T 字头
TD-乍得(CHAD) 
TG-多哥(TOGO) 
TH-泰国(THAILAND) 
TJ-塔吉克斯坦(TAJIKISTAN) 
TM-土库曼(TURKMENISTAN) 
TN-突尼斯(TUNISIA) 
TR-土耳其(TURKEY) 
TW-台湾省(TAIWAN) 
TZ-坦桑尼亚(TANZANIA) 

U字头
UA-乌克兰(UKRAINE) 
UG-乌干达(UGANDA) 
US-美国(UNITED STATES) 
UY-乌拉圭(URUGUAY) 
UZ-乌兹别克(UZBEKISTAN) 

V 字头
VC-圣文森特岛(SAINT VINCENT) 
VE-委内瑞拉(VENEZUELA) 
VN-越南(VIET NAM) 

Y 字头
YE-也门(YEMEN) 
YU-南斯拉夫联盟(YUGOSLAVIA) 

Z 字头
ZA-南非(SOUTH AFRICA) 
ZM-赞比亚(ZAMBIA) 
ZR-扎伊尔(ZAIRE) 
ZW-津巴布韦(ZIMBABWE)
















　专业代码：B080728

　　专业名称：计算机软件及应用（独立本科段）#

　　主考学校：北京大学

　　开考方式：独立办班

　　报考范围：全省

类型序号　

课程代号　

课程名称　

学分　

类型　

考试方式　

001 　	03708 　	中国近代史纲要 　	2 　	必考 　	笔试 　
002 　	03709 　	马克思主义基本原理概论 　	4 　	必考 　	笔试 　
003 　	00015 　	英语（二） 　	14 　	必考 　	笔试 　
004 　	00023 　	高等数学（工本） 　	10 　	必考 　	笔试 　
005 　	08903 　	数据库技术基础及应用 　	3 　	必考 　	笔试 　
006 　	01048 　	计算机操作系统 　	3 　	必考 　	笔试 　
007 　	07016 　	编译原理 　	5 　	必考 　	笔试 　
007 　	09342 　	编译原理 　	1 　	必考 　	实践考核 　
008 　	06540 　	计算机网络 　	4 　	必考 　	笔试 　
009 　	02010 　	概率论与数理统计（一） 　	7 　	必考 　	笔试 　
010 　	02333 　	软件工程 　	4 　	必考 　	笔试 　
010 　	02334 　	软件工程 　	1 　	必考 　	实践考核 　
011 　	04644 　	计算机图形学 　	4 　	必考 　	笔试 　
011 　	04645 　	计算机图形学 　	1 　	必考 　	实践考核 　
012 　	04905 　	计算机结构原理 　	3 　	必考 　	笔试 　
012 　	04906 　	计算机结构原理 　	2 　	必考 　	实践考核 　
013 　	11339 　	计算机软件及应用课程实验（二） 　	5 　	必考 　	实践考核 　
014 　	06999 　	毕业论文 　	不计学分 　	必考 　	实践考核 　
201 　	11484 　	PASCAL程序设计 　	4 　	加考 　	笔试 　
202 　	02331 　	数据结构 　	3 　	加考 　	笔试 　
203 　	01307 　	微机原理及应用（实践） 　	1 　	加考 　	实践考核 　
203 　	04549 　	微机原理及应用 　	5 　	加考 　	笔试 　
204 　	01242 　	微机基础及操作 　	5 　	加考 　	笔试 　
205 　	06626 　	数字逻辑 　	4 　	加考 　	笔试 　
206 　	11340 　	计算机软件及应用课程实验（三） 　	4 　	加考 　	实践考核　
　　课程设置：必考课14门72学分；加考课6门26学分。

　　说明：

　　1、013课程含005、006课程实验各2学分，008课程实验1学分，206课程含201课程实验2学分，202、205课程实验各1学分，须相关课程笔试全部合格后方可报考。

　　2、计算机软件及应用、计算机及应用专业专科毕业生可直接报考本专业，其他专业专科（或以上）毕业生报考本专业须加考201至206，已取得相同名称课程考试成绩合格者可申请免考。

　　3、本专业仅接受国家承认学历的专科（或以上）毕业生报考。




========================================================
支气管扩张症是一种继发的病症。患者过去多曾患过麻疹、百日咳、支气管肺炎等疾病。以后又经常有呼吸道感染的反复发作。支气管及其周围肺组织的慢性炎症损坏了支气管管壁，削弱了它的弹性，最后形成支气管扩张和变形。

    支气管扩张的典型症状是长期咳嗽，咳大量脓痰，反复咯血或痰中夹血。有的病人还有一些全身性症状，如发热、盗汗、食欲减退、消瘦、贫血等。中医认为，其病因由于肺热气燥，清肃之气不行，脾胃上输之津液转从热化，煎熬而成痰沫；外邪侵袭，肺气壅遏不宣，因而咳嗽；肺有燥热，伤及肺系之脉络，而致咯血。采用药膳调治，可使病情稳定，症状改善或消失。介绍如下，不妨一试。

    川贝杏仁粥　取川贝母、杏仁各10克，百合30克，大米100克，蜂蜜30克，梨2个。将前三味捣碎，梨捣烂挤汁，共放锅内，和粳米一起加水煮粥。粥将熟时加入蜂蜜，再煮片刻即成。空腹服食，每日1次。10天为1疗程。方中川贝、杏仁、百合清肺化痰、润肺定喘；蜂蜜润燥，为肺燥咳嗽之佳品；梨养阴清热、润肺清津；大米养胃和脾。常服可清肺化痰、益气生津、扶正强身。

    猪肺薏米粥  将猪肺1叶洗净切成条状，加生薏米、粳米各50克，水煮成粥。再加蜂蜜适量，代早餐服食。每日1次，7天为1疗程。方中猪肺可“以脏补脏”，主治肺虚咳嗽、咯血；生薏米为清肺排脓的佳品；粳米益气和中。支扩症患者常服本方，有清肺化痰、扶正祛邪之功。

    白鸭煨虫草  白鸭1只，冬虫夏草60克。宰鸭去毛及内脏，洗净；冬虫夏草以纱布包裹，用线扎好，放入鸭腹中，加水煨至鸭肉烂熟为度，放盐少许。食肉饮汤，分6次，3天内服完。5只鸭为1疗程。方中鸭为清补之佳品。据《随息居饮食谱》载：鸭肉能滋五脏之阴，清虚劳之热，可养胃、补血、生津、止嗽。冬虫夏草为调补阴阳的良药，既可滋肺阴，又能补肾阳。支扩症患者服用本方，有滋肺益肾、宁嗽化痰的功效。

    阿胶粳米粥  以粳米100克加水煮粥，粥将熟时，加入捣碎的阿胶30克，文火炖煮，边煮边搅3～4沸，加入红糖适量调味，空腹服食，每日1次，半个月为1疗程。方中阿胶具有养血止血作用，粳米补脾益肺。合煮成粥，具有滋阴补虚、养血止血之功效，对支扩症之咯血颇有效验。
==========================================================


本病多属中医“咳血”范畴。伴有急性感染时又多属“肺痈”，伴结核感染时又多属“肺痨”。本病临床常见有燥热犯肺、痰热壅盛、肝火犯肺、阴虚肺热四证。(1)燥热犯肺型，症见咳嗽，痰中带血，口鼻干燥，或有身热，舌红少苔，脉细数。治宜清热润肺、宁络止血。(2)痰热壅盛型，症见身热，振寒，继则壮热，咳痰呈黄绿色腥臭痰，咳血量多色鲜红，口干咽燥，舌红、苔黄腻，脉滑数。治宜清肺排脓，化瘀止血。(3)肝火犯肺型，症见咳嗽阵作，痰中带血或纯血鲜红，胸胁胀痛，烦躁易怒，口苦，舌红、苔薄黄，脉象弦数。治宜清肝泻肺，凉血止血。(4)阴虚肺热型，症见咳嗽有痰，痰中带血或反复咳血，血色鲜红，口干咽燥，颧红，潮热，盗汗，五心烦热，舌红少苔，脉细数。治宜滋阴润肺，宁络止血。 

    方1  海蜇马蹄汤 
    组成：海蜇皮、猪腱各200克，马蹄10个，生姜1片，盐少许。 
    用法：瓦煲内加清水，用猛火煲滚，放人马蹄、猪腱、生姜，改用中火煲2小时，再加人海蜇皮，煲45分钟，加盐调味即可。 
    功效：清热化痰。 
    主治：支气管扩张症，属痰热壅盛型，咳痰呈黄绿色腥臭痰，口干咽燥，身热，舌红、苔黄腻，脉数。 

    方2  丝瓜杏仁排骨汤 
    组成：丝瓜3条，排骨250克，南北杏20克，生姜3片。 
    用法：将上述用料一齐放人清水煲内，大火煲滚后，改慢火煲2小时，下盐调味即可。 
    功效：去热除痰。 
    主治：支气管扩张症，属痰热壅盛型，身热，咳吐黄绿色腥臭痰，口干咽燥，舌红、苔黄者。 

    方3  三汁蜂蜜饮 
    组成：生萝卜250克，鲜藕250克，梨2个，蜂蜜25克。 
    用法：将萝卜、藕、梨洗净后切碎榨汁服。 
    功效：清热润肺。 
    主治：支气管扩张症，属燥热伤肺型，咳嗽咳痰，痰中带血，口鼻干燥，舌红、苔少者。 
    
方4  百合膏 
    组成：干百合100克，蜂蜜150克。 
    用法：将干百合洗净后，放人碗内，加入蜂蜜，蒸1小时，趁热调均匀，晾凉后装入瓶内即成。每日早晚各服l匙。 
    功效：滋阴润肺。 
    主治：支气管扩张症，属阴虚肺热型，咳嗽咳痰量少，痰中带血，口干咽燥，潮热盗汗者。 
    
方5  花杏补浆 
    组成：花生仁15克，杏仁15克，黄豆15克。 
    用法：上三味共研成浆煮熟早晚饮服。 
    功效：润肺止咳。 
    主治：支气管扩张症，属燥热伤肺型，肺燥久咳，痰中带血丝，口鼻干燥，舌红、苔薄者。 
    
方6 胡桃蜜糕 
    组成：胡桃1000克，蜂蜜1000克。 
    用法：胡桃捣烂与蜂蜜和匀，瓶装。每服1匙，1日2次。 
    功效：滋阴润肺。 
    主治：支气管扩张症，属阴虚肺热型，咳嗽日久，痰中夹血，口干咽燥，潮热盗汗，五心烦热，舌红、苔少者。 














T领袖：年入过亿（例如任正非、马化腾、李彦宏、丁磊、马云等，包括期权股票以及投资理财等收入。）
 
IT大哥：年入千万（级别次于以上几位大佬的公司老板，不缺钱，普遍对上一条里的人物羡慕嫉妒恨。）
 
IT精英：年入百万（各IT公司副总裁级别人物，包括COO、CTO等，大多为职业经理人，赚够前就跑。）
 
IT人才：年入50万（各IT公司总监级别人物，有房有车，生活压力相对较小）
 
IT工程师：年入20万（高级经理级别，有房贷，生活压力大）
 
IT民工：年入10万（经理级别，基本无房，学会装波一，生活压力大）
 
码农：年入6万到10万（工作三四年，租房，继续混
日子）
 
码奴：年入3万到6万（工作一两年，租房，混日子）
 
码畜：年入低于3万（刚毕业的，租房，傻乐）




中山大学附属第一医院
中山大学附属第二医院(孙逸仙纪念医院)
中山大学附属第三医院
中山大学肿瘤医院
中山大学眼科中心
南方医科大学附属南方医院
南方医科大学附属珠江医院
广州中医药大学第一附属医院
广州中医药大学第二附属医院（广东省中医院）
暨南大学医学院第一附属医院（广州华侨医院）
广东省人民医院（广东省精神卫生研究所）
广东省妇幼保健院（广州医学院附属广东省妇儿医院）
广州医学院第一附属医院（原广州市工人医院）
广州医学院第二附属医院
广州医学院附属广州市第一人民医院
广州医学院附属广州市第二人民医院
广州市中医院
广州市妇婴医院（广州医学院附属妇婴医院）
广州医学院附属儿童医院
广州市红十字会医院（暨南大学医学院第四附属医院）
广州市胸科医院
广州市精神病医院（广州市脑科医院）
广州铁路中心医院
广东三九脑科医院




Job Duties:
Develop IT solutions including requirement gathering, technical design, coding and testing according to established standards and best practices;
Participate in system testing, UAT, implementation and rollout to sites;
Provide post-release support;
Some after-hours production support is required but is rotated equally amongst the team.
 
Candidate Specifications:
At least one year of Mainframe development and support experience;
Familiar with COBOL programming would be preferred;
Strong analytical, interpersonal and problem-solving skills;
Effective communication skills in spoken and written English;
Ability to work under pressure on tight schedule.










******************************************** 观音借库 *******************************************

农历正月廿六日，是一年一度的观音开库日子。  乘龙观音据传，观音在修道的时候，有五百位护法罗汉，为了要考核观音大士的修行成绩，于是化为人间和尚，到观音庙化缘讨饭充饥。
　　观音见有和尚求助，就打开仓库让各和尚尽情享用各种精美斋菜，当五百和尚填满肚皮之后，余下来的食物就留给前来参拜的善信享用。
　　此后，农历正月廿五日晚子时就定为“观音开库”日。每年的这个日子，千千万万的信徒，都会涌到观音庙祈福及借库，希望借库后财运亨通。
　　近年，香港经济渐趋低迷，市民的消费力更加薄弱，失业人数创新高，有一份工已算是幸运儿，属于仅可糊口“吊盐水”的人，比比皆是。打开报章的港闻，差不多每天都有市民因经济问题困扰而走上绝路，宝贵生命就此了结，听来令人唏嘘！
　　金钱不是万能，但没有钱却万万不能，起居饮食、交租买米，非钱不可，是故，人人为钱搏命。要向银行借货么，谈何容易？有人为救一时之急，向“大耳窿”求助，结果被迫到走投无路，这一切，已是司空见惯。
　　想来，最仁慈、最可信、最无私的，应该是“观音娘娘”，只要到观音庙上香求借，全部得偿所愿。每年农历正月二十六日子时至亥时，观音菩萨大开金库，借钱于民，助民致富的时刻。
　　“借库”所具备的供品，大抵和作观音福相同。至于仪式方面，借库的善信可在燃点香烛后，恭敬地跪在观音面前说出自己的愿望，想借多少钱？用什么供品还神？都应说得一清二楚，然后才焚化金银衣纸。
　　不过有一点要注意，携来的金纸银纸最好剩下几只叠好的寿金元宝或大金元宝，待祭祀完毕带回家中，放在神位旁边或流年的财气位。
　　如果借了观音的钱做生意而发了财，别忘了翌年正月二十六日前回到观音庙，履行先前许下的诺言。此外，去年带回家的寿金应带回庙中焚化。
　　到现在，每逢“观音开库”的日子到来借库的善信也越来越多。虽然，观音来者不拒，但大家要谨记∶借贷之后，到了年尾，一定要归还，否则，下次再借库时就不再灵验了。
编辑本段
程序

　　下列是最常见的作福物品∶
　　香三枝。红烛一对。或另加长寿香。
　　拜观音的金银衣纸一份：
　　观音衣、大光宝、寿金或潮州金、长禄马、圆禄马、转运宝牒、
　　百解符、贵人符等。
　　五斋：
　　五种不同的蔬菜生果。可用橙、苹果、提子、雪梨、水晶梨或其他生果。
　　罗汉斋用五种菜炒在一起，故罗汉斋代表另外五种斋菜。
　　茶三杯、水三杯、筷子三对。切忌用酒、用荤。
　　先燃点红烛，叩拜三次，然后插在香炉上。接着燃点檀香三枝，也叩拜三次，插香炉上。
　　如果念咒颂经，增强感通。
　　流行的经文有心经、观音心咒，或六字大明咒，效力一样。
　　说一些吉利话，祈求观世音菩萨保佑，身体健康，恶运尽除。
　　最后，将金银衣纸焚化。焚化时再念观音心咒十八遍或一○八遍。
　　礼成。
　　观音咒：
　　南呒佛
　　南呒佛
　　南呒僧
　　南无救苦救难观世音菩萨
　　怛只他（丹之拖）
　　（庵）
　　伽罗伐哆（骑喇花多）
　　伽罗伐哆（骑喇花多）
　　伽诃伐哆（喇骑花多）
　　罗伽伐哆（喇骑花多）
　　娑婆诃（梭婆呵）
　　观音借库：
　　准备香烛；
　　诚心上香；
　　上香祈拜之后，敲钟三下，示意观音大士得悉∶信徒前往借库；
　　依照指示，到“金银库”取利是，然后再取生菜红包，内有花生或莲子等食物，最好吃下肚里去，不要丢弃。
　　离开观音庙之前，再一次向观音许下承诺，年底回来酬神。
　　善信为了表示诚心祈求，在“借库”前后，有几点值得注意∶
　　借库前，斋戒沐浴，以表真诚；
　　上香前请洗手；
　　借库时，要表达阁下是何许人？家住何方？及出生日期。
　　不能求赌胜之道，要求正财；
　　你有什么希望？祈求时立即道出，记着∶不要太贪心，足够便可；
　　借库日不一定要在农历正月二十五日，只要诚心，任何一日均可。
　　还有一点更重要的是借库之日忌食与肉有关的食物，例如猪肉、鸡红绝不能沾口，否则会遭遇血光之灾。
　　其次，借库返家后，要在东南方向注上九九共八十一枝香，以谢神恩为要。
　　那么，到“观音庙”求财，应该借贷若干？据说，“观音开库”借贷数目是没有限制的，从一千万到十亿都可以，不过，信徒应该知道，在观音大士之前不要太贪心，其实，除了钱之外，健康、平安和好姻缘也是非常重要的。
　　一位庙祝向信徒告诫说∶“除了向观音借贷之外，同时也可以向观音借心愿，也许，完成自己的心愿，比金钱更为重要。”
　　许多风水师认为∶正月二十六日，观音开库，港九最有利的财位是位于新界北区的八乡观音庙，及位于东南面的红|观音庙，最好的良辰是早上五时到七时，九时到十一时，或下午的一时至三时。


克利斯朵夫生出了耶稣基督
耶稣基督又生出了整个世界整个世界 
可是克利斯朵夫当时何处立足


克利斯朵夫生出了耶稣基督
耶稣基整个世界
当时何处立足


    
    




交易日期 支出 存入 余额 交易类型 交易备注 
2011-09-01 1,200.00   51.70 银联ATM取款 银联 ATM 1352 
2011-09-01 2.00   49.70 ATM跨行费 银联 ATM 跨行取款手续费 
2011-09-07 10.00   39.70 电信 00TL:820531:20110907:5311109079135635 
2011-09-09   2,072.00 2,111.70 代发工资 代发工资 
2011-09-09 1,000.00   1,111.70 银联ATM取款 银联 ATM 4340 
2011-09-09 2.00   1,109.70 ATM跨行费 银联 ATM 跨行取款手续费 
2011-09-14 100.00   1,009.70 银联POS消费 银联消费 303189 
2011-09-16   2.00 1,011.70 代发其它 201108 手续费返还 
2011-09-21   1.03 1,012.73 账户结息 活期结算户结息 :1.03 扣税 :.00 
2011-09-21 800.00   212.73 客户转帐 800.00 陆榕连 
2011-09-21 2.00   210.73 业务收费 同城转他行手续费（非柜面） 
2011-10-03 29.75   180.98 网上消费 网上消费 订单号 :2199063541 
2011-10-07 10.00   170.98 电信 00TL:820531:20111007:5311110079585231 
2011-10-07 50.00   120.98 银联POS消费 银联消费 602346 
2011-10-13 100.00   20.98 银联ATM取款 银联 ATM 5153 
2011-10-13 2.00   18.98 ATM跨行费 银联 ATM 跨行取款手续费 
2011-10-19   2.00 20.98 代发其它 201109 手续费返还 
2011-11-07 14.20   6.78 电信 00TL:820531:20111107:5311111070020016 
2011-11-07   1,000.00 1,006.78 柜台存现   
2011-11-09 100.00   906.78 银联POS消费 银联消费 851847 
2011-11-09 600.00   306.78 银联ATM取款 银联 ATM 4535 
2011-11-09 2.00   304.78 ATM跨行费 银联 ATM 跨行取款手续费 
2011-11-10 300.00   4.78 客户转帐 300 朱春霖 
2011-11-10 2.00   2.78 业务收费 异地普通汇款手续费（非柜面） 
2011-11-23   2.00 4.78 代发其它 201110 手续费返还 
2011-12-21   0.10 4.88 账户结息 活期结算户结息 :.10 扣税 :.00 
2011-12-22   2.00 6.88 代发其它 180154 手续费返还 
2011-12-30   510.00 516.88 网上交易费 431174545| 支付宝提 
2011-12-30   1,000.00 1,516.88 柜台存现   
  支出交易笔数： 19   存入交易笔数： 10  
  支出金额合计： 4,325.95   存入金额合计： 4,591.13   
 
<<<<<<< .mine




北条香理,苍井空,川滨奈美,堤莎也加,町田梨乃,二阶堂仁美,饭岛爱,饭田夏帆,饭冢友子,芳本叶月,冈崎结由,冈田丽奈,高木萌美,高田礼子,高原流美,宫本真美,宫岛司,古都光,光月夜也,河村亚季子,河井梨绪,黑崎扇菜,奈良沙绪理,浅丘南,秋本那夜,秋山玲子,秋庭比吕子,三尺真奈,三井保奈美,森下真理,山吹美花,山口纱弥加,杉里香,神代弓子,树梨沙,水谷利加,松鸠永里奈,松山麻美,松屿初音,塔山直美,藤香南子,天使美树,天野理惠,田崎由希,桐岛淳子,尾崎美果,西野美绪,相泽优香,小林里实,小早川洋子,叶山小姬,樱树露衣,樱田佳子,永井绘理香,远藤真纪,早川美波,早川桃香,折原琴,中鸠广香,中泽夏木,竹野内丰,佐藤江梨花,爱内萌,爱田露美,爱田毛毛,安倍夏实,安原真美,奥山香,八木泽,白川美奈美,白鸟智惠子,白亚朱里,北山静香,北原步,北原真裕,仓本安奈,仓田杏里,朝比奈真理,朝仓加穗里,朝仓玛丽亚,持田茜,冲田由加里,川奈由依,大友梨奈,岛田香奈,堤沙也加,渡边香,风间舞,风见京子,福山洋子,冈本夏生,高仓梨奈,高野瞳,宫本瞳,宫本阳子,宫地奈,宫间沙布子,工藤瞳,宫下杏菜,河田纯子,和希结衣,横山千枝,华美月,姬野莉梦,朝美光,朝美绘乃香,朝丘瞳,朝霞佳绘美,赤西凉,川野亚希子,大久保玲,饭干惠子,福光千穗,冈田安希,星美织,杨原京子,早川濑里奈,斋藤朝子,长泽筑实,中谷香织,中森子,中条美华,竹内爱,庄司爱,佐藤春菜,佐藤子,津野田熏,吉井玲奈,阿嘉奈津,安藤希,安田奈央,奥川希美,奥山美夏,白鸟美由纪,百合香,北村夕起,北山英里,朝仓志穗,朝丘南,朝丘纱智,朝日美穗,朝永真弥,朝长真弥,纯名梨沙,村田洋子,大林典子,二瓶有香,芳贺优里雅,妃今日子,福美香织,冈本多绪,刚野凤子,高桥由美子,桂木萌,河合梓,横须贺,吉成香,吉村优,臼井里绘,橘友贺,来栖凉子,濑户美贵子,濑雅子,林绘里,玲樱奈,美月由奈,梦野玛丽亚,秘叉华,木内美步,木尾原真弓,牧野泉,鲇川直美,清水理惠子,c原舞,泉由香,三浦桃,松树梨,松下真依子,松元伊代,藤宫知世,田村茜,田真潮,桐岛惠理香,|原真弓,西尾佑里,相泽朝海,相泽沙赖,小阪光,小仓艾莉丝,筱峰爱,野乃原,优里香,由津希,泽绪凛,长曾我部蓉子,真莉亚,武腾兰，渡赖晶，真崎麻衣,仲根佳绘美,爱原千芙,绫波优,奥菜千春,奥菜翼,八木原麻优,白川沙也加,白石枫,白石麻梨子,宝来美雪,北原雪,宝生琉璃,草剃纯,长濑茜,赤阪梨乃,赤阪美步,大路惠美,岛津讶子,德井唯,儿岛香绪里,福泽京子,宫泽璃音,吉野美穗,橘琉璃,濑户准,濑名凉子,片濑梨音,齐藤美穗,枪田彩野,桥本美步,三笑明日香,上原绘里香,石井淳笑,松冈理穗,松井夏穗,松元亚璃沙,唐泽美树,小池绘美子,小泉琉美,小山涉,小野谷实穗,星野琉海,续丽子,岩崎美穗,泽山凉子,辰巳奈都子,热田久美,姬野香,本瑞?,本瑞?,木加奈?,星野真唯,八木泽莉央,八木泽景一,柏木瞳一郎,坂下千里子,保坂拓见,北原一D,泷北智子,夏本加奈子,端本千奈美,爱本瑞穗,本树尤真,仓内安奈,小鹿纯子,长坂仁惠,赤坂丽,赤坂七惠,赤D伶奈,川村美D,春日D衣,镰田奈津美,风见里穗,富田梨惠,高坂真由,宫D志帆,光D玲奈,黑坂真美,胡桃泽马里奈,吉成香子,吉田亚D,今井优,井坂绘美,久留须由美,蓝田美丰,笠木彩花,丰岛真千子,铃木美生,吉田亚纪子,川淳子,美D沙耶,美D亚弥,美D亚沙,梦D亚由,乃木真利子,乃坂绘美,佐藤和沙,金子纱香,片濑梨子,中岛千晶,浅野京子,吉泽有希子,濑间幸美,金子美铃,三田爱里,三田友[,三D真绪,D小雪,沙耶香,相田纱耶香,杉田美园,侍山凉子,山崎亚美,山D萌,山D千里,山D舞,山D亚香里,山D一步,长濑美优,长濑美华,樱井美优,坂上友香,神乐坂惠,神田朱未,神田美D,小岛圣,泽诗奈奈子,石川施恩惠,石坂伊津佳,水D凉子,广末凉子,广重绫,菅崎茜……=======


希志艾路
rio 柚木提娜>>>>>>> .r820
麻仓优












城市	职位名称	申请日期	公司名称	竞争力	申请简历名称	投诉	
广州	C++程序员	        2011-12-20	广州联奕信息科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	C/C++软件开发工程师	2011-12-20	北京达内金桥科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	C/C++ 软件工程师	2011-12-20	广州名扬信息科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	C++开发工程师	        2011-12-1	广州菲音信息科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师	        2011-12-1	联欣自动识别技术限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	VC/VC++程序员（偏界面-不限学历，待遇从优）	2011-12-1	广州市泰极信息科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件编程工程师	        2011-12-1	广州神科光电科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	C/C++ 软件工程师	2011-12-1	广州名扬信息科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	C/C++ 网络开发工程师	2011-12-1	广州瀚信通信科技股份有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师	2011-12-1	上海海同信息科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	C/C++/VC软件工程师（应届毕业生）	2011-12-1	中数通信息有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	游戏软件开发工程师	2011-12-1	广州市立展动漫科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	Linux开发工程师	2011-12-1	加拿大美瑞威有限公司广州代表处	查看	计算机软件/系统集成 1年 广州	投诉
广州	游戏软件工程师	2011-11-21	广州万昶动漫科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件开发工程师/助理工程师	2011-11-21	上海三越软件科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	C/C++服务端开发工程师（C/C++程序员）	2011-11-5	广州银汉科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉


广州	软件工程师（初级、中级、高级）	2011-12-31	广州市域普软件科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件开发工程师/助理工程师	2011-12-31	上海三越软件科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	初级软件工程师	2011-12-31	广州数联软件技术有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师	2011-12-31	广州数联软件技术有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师(广州)	2011-12-20	烽火通信南京研发中心	查看	计算机软件/系统集成 1年 广州	投诉
广州	Linux软件工程师	2011-12-20	广东宏景科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件开发工程师	2011-12-20	广东综联数码科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师	2011-12-20	广州市联科软件有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件人员	2011-12-20	广州维柯信息技术有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	Linux开发工程师	2011-12-20	加拿大美瑞威有限公司广州代表处	查看	计算机软件/系统集成 1年 广州	投诉
广州	广州移动技术类岗位（计算机类）	2011-12-20	广东邮电人才服务有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	C++程序员	2011-12-20	广州联奕信息科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件开发工程师	2011-12-20	广东综联数码科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	初级软件工程师（开放方向）	2011-12-20	中国民航信息网络股份有限公司广州分公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师	2011-12-20	广州市毓秀文化传播有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师	2011-12-20	广东暨通信息发展有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师（专业不限）；需3个月的岗前培训。	2011-12-20	北大青鸟广州唯一软测校区	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师	2011-12-20	联欣自动识别技术限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师	2011-12-20	软通动力信息技术(集团)有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师	2011-12-20	广州市联科软件有限公司	查看	计算机软件/系统集成 1年 广州	投诉



广州	软件工程师	2011-12-31	广州市三才通讯科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	C/C++ 软件工程师	2011-12-31	广州名扬信息科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	C++软件工程师	2011-12-31	广州白云国际机场白云安检科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件开发实习生	2011-12-31	北京达内金桥科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师（实习培训生）	2011-12-31	广州市科传计算机科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件开发工程师	2011-12-31	广东综联数码科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师（VC）	2011-12-31	广州雅迅科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件编程工程师	2011-12-31	广州神科光电科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	C++中级软件工程师	2011-12-31	广州阿思博信息技术有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师（Java、C语言、数据库方向）	2011-12-31	元镁信息科技（上海）有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件实施工程师（地点：广州）	2011-12-31	深圳市康拓普信息技术有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	技术中心软件工程师	2011-12-31	广州杰赛科技股份有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	技术中心软件工程师	2011-12-31	广州杰赛科技股份有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	技术中心软件工程师	2011-12-31	广州杰赛科技股份有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师(广州)	2011-12-31	烽火通信南京研发中心	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件开发工程师	2011-12-31	广东德生科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	Linux软件工程师	2011-12-31	广东宏景科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师	2011-12-31	元镁信息科技（上海）有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师	2011-12-31	软通动力信息技术(集团)有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师	2011-12-31	广州市联科软件有限公司	查看	计算机软件/系统集成 1年 广州	投诉



广州	C++软件工程师	2012-1-6	广州阿思博信息技术有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	linux数据平台开发工程师	2012-1-6	广东宜通世纪科技股份有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	C/C++ 网络开发工程师	2012-1-6	广州瀚信通信科技股份有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	C/C++ 软件工程师	2012-1-6	广州名扬信息科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	服务端开发工程师（erlang）	2012-1-6	广州明朝网络科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	linux程序员	2012-1-6	广州科学城科技企业	查看	计算机软件/系统集成 1年 广州	投诉
广州	linux数据平台开发工程师	2012-1-6	广东宜通世纪科技股份有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师	2012-1-6	广东省数字广东研究院	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件开发工程师	2012-1-6	广州理想电子信息技术有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	游戏软件工程师	2012-1-6	广州视源电子科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	游戏软件工程师	2012-1-6	广州视源电子科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	linux程序员	2011-12-31	广州科学城科技企业	查看	计算机软件/系统集成 1年 广州	投诉
广州	C++程序员	2011-12-31	广州联奕信息科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	游戏开发工程师(客户端)	2011-12-31	广州市狼影动漫科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件技术人员	2011-12-31	广州维柯信息技术有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师	2011-12-31	广东暨通信息发展有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	软件工程师	2011-12-31	广州市毓秀文化传播有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	程序员	2011-12-31	广州巨蛋计算机软件有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	初级程序员	2011-12-31	广州亦高软件科技有限公司	查看	计算机软件/系统集成 1年 广州	投诉
广州	C/C++软件开发工程师/高级工程师	2011-12-31	埃森哲(中国)有限公司广州分公司	查看	计算机软件/系统集成 1年 广州	投诉





























鞋子尺码

　　鞋子的尺码，又叫鞋号，常见有以下标法：国际、欧洲、美国和英国。
　　国际标准鞋号表示的是脚长的毫米数。
　　中国标准采用毫米数或厘米数。如：245是毫米数，24 1/2是厘米数，表示一样的尺码。
　　换算公式：
　　厘米数×2－10=欧制 （欧制+10）÷2=厘米数
　　厘米数－18+0.5=美制 美制+18－0.5=厘米数
　　厘米数－18－0.5=英制 英制+18+0.5=厘米数
　　鞋号对照表：
　　女鞋　
　　
脚长 cm	22.5	23	23.5	24	24.5	25	25.5	26
欧洲EUR	35	36	37	38	39	39	40	40
美国 US	5	5.5	6	6.5	7	7.5	8	8.5
英国 UK	4	4.5	5	5.5	6	6.5	7	7.5
　　男鞋
　　
脚长 cm	24.5	25	25.5	26	26.5	27	27.5	28
欧洲EUR	39	40	41	42	43	44	45	46
美国 US	7	7.5	8	8.5	9	9.5	10	10.5
英国 UK	6	6.5	7	7.5	8	8.5	9	9.5







------------------------- tips for interview ---------------------------
words and deeds
1) self-confident
2) polite
  

<<<<<<< .mine



春季	
立春雨水惊蛰春分清明谷雨
夏季	
立夏小满芒种夏至小暑大暑
秋季	
立秋处暑白露秋分寒露霜降
冬季	
立冬小雪大雪冬至小寒大寒=======

11:06 2012-3-5
     六大淫邪之气: 
     风 寒 湿 燥 火 暑
     >>>>>>> .r892



中华人民共和国外交部　　部长：杨洁篪
中华人民共和国国防部　　部长：梁光烈（兼）
中华人民共和国国家发展和改革委员会　　主任：张　平（全日制中专学历）
中华人民共和国教育部　　部长：袁贵仁
中华人民共和国科学技术部　　部长：万　钢（致公党中央主席）
中华人民共和国工业和信息化部　　部长：苗　圩
中华人民共和国国家民族事务委员会　　主任：杨　晶（蒙古族）
中华人民共和国公安部　　部长：孟建柱（兼）
中华人民共和国国家安全部　　部长：耿惠昌
中华人民共和国监察部　　部长：马　b（女，中纪委副书记）
中华人民共和国民政部　　部长：李学举
中华人民共和国司法部　　部长：吴爱英（女）
中华人民共和国财政部　　部长：谢旭人
中华人民共和国人力资源和社会保障部　　部长：尹蔚民
中华人民共和国国土资源部　　部长：徐绍史
中华人民共和国环境保护部　　部长：周生贤
中华人民共和国住房和城乡建设部　部长：姜伟新
中华人民共和国交通运输部　　部长：李盛霖
中华人民共和国铁道部　　部长：盛光祖
中华人民共和国水利部　　部长：陈　雷
中华人民共和国农业部　　部长：孙政才
中华人民共和国商务部　　部长：陈德铭
中华人民共和国文化部　　部长：蔡　武
中华人民共和国卫生部　　部长：陈　竺（无党派人士）
中华人民共和国国家人口和计划生育委员会主任：李　斌（女）
中国人民银行　　行长：周小川
中华人民共和国审计署　　审计长：刘家义







SQL语句优化的原则：

　　1.使用索引来更快地遍历表
　　缺省情况下建立的索引是非群集索引，但有时它并不是最佳的。在非群集索引下，数据在物理上随机存放在数据页上。合理的索引设计要建立在对各种查询的分析和预测上。一般来说：①.有大量重复值、且经常有范围查询(between, > ,< ，> =,< =)和order by、group by发生的列，可考虑建立群集索引;②.经常同时存取多列，且每列都含有重复值可考虑建立组合索引;③.组合索引要尽量使关键查询形成索引覆盖，其前导列一定是使用最频繁的列。索引虽有助于提高性能但不是索引越多越好，恰好相反过多的索引会导致系统低效。用户在表中每加进一个索引，维护索引集合就要做相应的更新工作。

　　2.IS NULL 与 IS NOT NULL
　　不能用null作索引，任何包含null值的列都将不会被包含在索引中。即使索引有多列这样的情况下，只要这些列中有一列含有null，该列就会从索引中排除。也就是说如果某列存在空值，即使对该列建索引也不会提高性能。任何在where子句中使用is null或is not null的语句优化器是不允许使用索引的。

　　3.IN和EXISTS
　　EXISTS要远比IN的效率高。里面关系到full table scan和range scan。几乎将所有的IN操作符子查询改写为使用EXISTS的子查询。
　　4.在海量查询时尽量少用格式转换。
　　5.当在SQL Server 2000中，如果存储过程只有一个参数，并且是OUTPUT类型的，必须在调用这个存储过程的时候给这个参数一个初始的值，否则会出现调用错误。
　　6.ORDER BY和GROPU BY
　　使用ORDER BY和GROUP BY短语，任何一种索引都有助于SELECT的性能提高。注意如果索引列里面有NULL值，Optimizer将无法优化。
　　7.任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。
　　8.IN、OR子句常会使用工作表，使索引失效。如果不产生大量重复值，可以考虑把子句拆开。拆开的子句中应该包含索引。

　　9.SET SHOWPLAN_ALL ON 查看执行方案。DBCC检查数据库数据完整性。
　　DBCC(DataBase Consistency Checker)是一组用于验证 SQL Server 数据库完整性的程序。

　　10.慎用游标
　　在某些必须使用游标的场合，可考虑将符合条件的数据行转入临时表中，再对临时表定义游标进行操作，这样可使性能得到明显提高。
    
　　优化数据库的方法：
　　1.关键字段建立索引。
　　2.使用存储过程，它使SQL变得更加灵活和高效。
　　3.备份数据库和清除垃圾数据。
　　4.SQL语句语法的优化。(可以用Sybase的SQL Expert，可惜我没找到unexpired的
　　序列号)
　　5.清理删除日志。
    
    
    
壹、贰、叁、肆、伍、陆、柒、捌、玖、拾、佰、仟、万、亿、元(圆)、角、分、零、整





*****************************
little endian
 255
 11111111 00000000 00000000 00000000

big endian
 257
 00000000 00000000 00000001 00000001
 







09:22 2012-07-21
------------- some reason of the app or dll run err at the target machine---------------------
1 no dependence dll
2 have dependence dll, but interface symbol do not match
3 have dependence dll, interface symbol do match, but no manifest(vs2005+)


23:43 2012-08-10
 net use /delete

16:18 2012-08-11
GetCurrentDirectoryA=======
12:11 2012-08-08
    LoadLibrary("sdtapi.dll") if no any path, it will search system path, like "system32", and     the last, will found the dir where the process start!!!
  


vc 6.0:
   first ignore nafxcw.lib libcmt.lib, then import it again. no no no, only input nafxcw.lib to "input", it works
      
   DWORD GetPrivateProfileString(LPCTSTR	lpAppName,
			         LPCTSTR	lpKeyName,
			         LPCTSTR	lpDefaut,
			         LPSTR	lpReturnedString,
			         DWORD	nSize,
			         LPCTSTR	lpFileName);
   




/****************************** Load DLL Seq *******************************************
process
	static: 
dynamic: [specific path] > 

module
static: the current dir of the module are
dynamic: {sys} > 




***********************************************************************************/
configure -platform win32-msvc2005 -xplatform wince60standard-armv4i-msvc2005

----------- set env
C:\Program Files\Microsoft Visual Studio 8\VC\ce\bin\x86_arm

C:\Program Files\Microsoft Visual Studio 8\VC\ce\include
C:\Program Files\Windows CE Tools\wce600\Mini210-CE6-SDK\Include\Armv4i

C:\Program Files\Microsoft Visual Studio 8\VC\ce\lib\Armv4i;C:\Program Files\Windows CE Tools\wce600\Mini210-CE6-SDK\Lib\ARMV4I


C:/Program Files/Microsoft Visual Studio 8/VC/ce
C:\Program Files\Windows CE Tools\wce600\Mini210-CE6-SDK



vs ide console app entry point: mainWCRTStartup  

_wfopen








Configures a communications device according to the specifications in a device-control block (a DCB structure). The function reinitializes all hardware and control settings, but it does not empty output or input queues.
Syntax
C++

BOOL WINAPI SetCommState(
  _In_  HANDLE hFile,
  _In_  LPDCB lpDCB
);

Parameters
hFile [in]
A handle to the communications device. The CreateFile function returns this handle.
lpDCB [in]
A pointer to a DCB structure that contains the configuration information for the specified communications device.
Return value
If the function succeeds, the return value is nonzero.
If the function fails, the return value is zero. To get extended error information, call GetLastError.
Remarks
The SetCommState function uses a DCB structure to specify the desired configuration. The GetCommState function returns the current configuration.
To set only a few members of the DCB structure, you should modify a DCB structure that has been filled in by a call to GetCommState. This ensures that the other members of the DCB structure have appropriate values.
The SetCommState function fails if the XonChar member of the DCB structure is equal to the XoffChar member.
When SetCommState is used to configure the 8250, the following restrictions apply to the values for the DCB structure's ByteSize and StopBits members:
The number of data bits must be 5 to 8 bits.





Initializes the communications parameters for a specified communications device.
Syntax
C++

BOOL WINAPI SetupComm(
  _In_  HANDLE hFile,
  _In_  DWORD dwInQueue,
  _In_  DWORD dwOutQueue
);

Parameters
hFile [in]
A handle to the communications device. The CreateFile function returns this handle.
dwInQueue [in]
The recommended size of the device's internal input buffer, in bytes.
dwOutQueue [in]
The recommended size of the device's internal output buffer, in bytes.
Return value
If the function succeeds, the return value is nonzero.
If the function fails, the return value is zero. To get extended error information, call GetLastError.
Remarks
After a process uses the CreateFile function to open a handle to a communications device, but before doing any I/O with the device, it can call SetupComm to set the communications parameters for the device. If it does not set them, the device uses the default parameters when the first call to another communications function occurs.
The dwInQueue and dwOutQueue parameters specify the recommended sizes for the internal buffers used by the driver for the specified device. For example, YMODEM protocol packets are slightly larger than 1024 bytes. Therefore, a recommended buffer size might be 1200 bytes for YMODEM communications. For Ethernet-based communications, a recommended buffer size might be 1600 bytes, which is slightly larger than a single Ethernet frame.
The device driver receives the recommended buffer sizes, but is free to use any input and output (I/O) buffering scheme, as long as it provides reasonable performance and data is not lost due to overrun (except under extreme circumstances). For example, the function can succeed even though the driver does not allocate a buffer, as long as some other portion of the system provides equivalent functionality.







auto eth0
iface eth0 inet dhcp
















Sign in
 Dev Center - Desktop
Home Dashboard Docs Samples Downloads Support Community
Dev Center - Desktop > Docs > Desktop app development documentation > Getting Started > Using the Windows Headers > Windows Data Types
Windows Data Types (Windows)
Learn how to develop for Windows desktop
Windows Development Reference
Getting Started
Using the Windows Headers
Windows Data Types
Large Integers

133 out of 190 rated this helpful - Rate this topic
The data types supported by Windows are used to define function return values, function and message parameters, and structure members. They define the size and meaning of these elements. For more information about the underlying C/C++ data types, see Data Type Ranges.
The following table contains the following types: character, integer, Boolean, pointer, and handle. The character, integer, and Boolean types are common to most C compilers. Most of the pointer-type names begin with a prefix of P or LP. Handles refer to a resource that has been loaded into memory.
For more information about handling 64-bit integers, see Large Integers.
Data type	Description
APIENTRY	
The calling convention for system functions.
This type is declared in WinDef.h as follows:
#define APIENTRY WINAPI
ATOM	
An atom. For more information, see About Atom Tables.
This type is declared in WinDef.h as follows:
typedef WORD ATOM;
BOOL	
A Boolean variable (should be TRUE or FALSE).
This type is declared in WinDef.h as follows:
typedef int BOOL;
BOOLEAN	
A Boolean variable (should be TRUE or FALSE).
This type is declared in WinNT.h as follows:
typedef BYTE BOOLEAN;
BYTE	
A byte (8 bits).
This type is declared in WinDef.h as follows:
typedef unsigned char BYTE;
CALLBACK	
The calling convention for callback functions.
This type is declared in WinDef.h as follows:
#define CALLBACK __stdcall
CALLBACK, WINAPI, and APIENTRY are all used to define functions with the __stdcall calling convention. Most functions in the Windows API are declared using WINAPI. You may wish to use CALLBACK for the callback functions that you implement to help identify the function as a callback function.
CCHAR	
An 8-bit Windows (ANSI) character.
This type is declared in WinNT.h as follows:
typedef char CCHAR;
CHAR	
An 8-bit Windows (ANSI) character. For more information, see Character Sets Used By Fonts.
This type is declared in WinNT.h as follows:
typedef char CHAR;
COLORREF	
The red, green, blue (RGB) color value (32 bits). See COLORREF for information on this type.
This type is declared in WinDef.h as follows:
typedef DWORD COLORREF;
CONST	
A variable whose value is to remain constant during execution.
This type is declared in WinDef.h as follows:
#define CONST const
DWORD	
A 32-bit unsigned integer. The range is 0 through 4294967295 decimal.
This type is declared in WinDef.h as follows:
typedef unsigned long DWORD;
DWORDLONG	
A 64-bit unsigned integer. The range is 0 through 18446744073709551615 decimal.
This type is declared in WinNT.h as follows:
typedef ULONGLONG DWORDLONG;
DWORD_PTR	
An unsigned long type for pointer precision. Use when casting a pointer to a long type to perform pointer arithmetic. (Also commonly used for general 32-bit parameters that have been extended to 64 bits in 64-bit Windows.)
This type is declared in BaseTsd.h as follows:
typedef ULONG_PTR DWORD_PTR;
DWORD32	
A 32-bit unsigned integer.
This type is declared in BaseTsd.h as follows:
typedef unsigned int DWORD32;
DWORD64	
A 64-bit unsigned integer.
This type is declared in BaseTsd.h as follows:
typedef unsigned __int64 DWORD64;
FLOAT	
A floating-point variable.
This type is declared in WinDef.h as follows:
typedef float FLOAT;
HACCEL	
A handle to an accelerator table.
This type is declared in WinDef.h as follows:
typedef HANDLE HACCEL;
HALF_PTR	
Half the size of a pointer. Use within a structure that contains a pointer and two small fields.
This type is declared in BaseTsd.h as follows:
C++

#ifdef _WIN64
 typedef int HALF_PTR;
#else
 typedef short HALF_PTR;
#endif

HANDLE	
A handle to an object.
This type is declared in WinNT.h as follows:
typedef PVOID HANDLE;
HBITMAP	
A handle to a bitmap.
This type is declared in WinDef.h as follows:
typedef HANDLE HBITMAP;
HBRUSH	
A handle to a brush.
This type is declared in WinDef.h as follows:
typedef HANDLE HBRUSH;
HCOLORSPACE	
A handle to a color space.
This type is declared in WinDef.h as follows:
typedef HANDLE HCOLORSPACE;
HCONV	
A handle to a dynamic data exchange (DDE) conversation.
This type is declared in Ddeml.h as follows:
typedef HANDLE HCONV;
HCONVLIST	
A handle to a DDE conversation list.
This type is declared in Ddeml.h as follows:
typedef HANDLE HCONVLIST;
HCURSOR	
A handle to a cursor.
This type is declared in WinDef.h as follows:
typedef HICON HCURSOR;
HDC	
A handle to a device context (DC).
This type is declared in WinDef.h as follows:
typedef HANDLE HDC;
HDDEDATA	
A handle to DDE data.
This type is declared in Ddeml.h as follows:
typedef HANDLE HDDEDATA;
HDESK	
A handle to a desktop.
This type is declared in WinDef.h as follows:
typedef HANDLE HDESK;
HDROP	
A handle to an internal drop structure.
This type is declared in ShellApi.h as follows:
typedef HANDLE HDROP;
HDWP	
A handle to a deferred window position structure.
This type is declared in WinUser.h as follows:
typedef HANDLE HDWP;
HENHMETAFILE	
A handle to an enhanced metafile.
This type is declared in WinDef.h as follows:
typedef HANDLE HENHMETAFILE;
HFILE	
A handle to a file opened by OpenFile, not CreateFile.
This type is declared in WinDef.h as follows:
typedef int HFILE;
HFONT	
A handle to a font.
This type is declared in WinDef.h as follows:
typedef HANDLE HFONT;
HGDIOBJ	
A handle to a GDI object.
This type is declared in WinDef.h as follows:
typedef HANDLE HGDIOBJ;
HGLOBAL	
A handle to a global memory block.
This type is declared in WinDef.h as follows:
typedef HANDLE HGLOBAL;
HHOOK	
A handle to a hook.
This type is declared in WinDef.h as follows:
typedef HANDLE HHOOK;
HICON	
A handle to an icon.
This type is declared in WinDef.h as follows:
typedef HANDLE HICON;
HINSTANCE	
A handle to an instance. This is the base address of the module in memory.
HMODULE and HINSTANCE are the same today, but represented different things in 16-bit Windows.
This type is declared in WinDef.h as follows:
typedef HANDLE HINSTANCE;
HKEY	
A handle to a registry key.
This type is declared in WinDef.h as follows:
typedef HANDLE HKEY;
HKL	
An input locale identifier.
This type is declared in WinDef.h as follows:
typedef HANDLE HKL;
HLOCAL	
A handle to a local memory block.
This type is declared in WinDef.h as follows:
typedef HANDLE HLOCAL;
HMENU	
A handle to a menu.
This type is declared in WinDef.h as follows:
typedef HANDLE HMENU;
HMETAFILE	
A handle to a metafile.
This type is declared in WinDef.h as follows:
typedef HANDLE HMETAFILE;
HMODULE	
A handle to a module. The is the base address of the module in memory.
HMODULE and HINSTANCE are the same in current versions of Windows, but represented different things in 16-bit Windows.
This type is declared in WinDef.h as follows:
typedef HINSTANCE HMODULE;
HMONITOR	
A handle to a display monitor.
This type is declared in WinDef.h as follows:
if(WINVER >= 0x0500) typedef HANDLE HMONITOR;
HPALETTE	
A handle to a palette.
This type is declared in WinDef.h as follows:
typedef HANDLE HPALETTE;
HPEN	
A handle to a pen.
This type is declared in WinDef.h as follows:
typedef HANDLE HPEN;
HRESULT	
The return codes used by COM interfaces. For more information, see Structure of the COM Error Codes. To test an HRESULT value, use the FAILED and SUCCEEDED macros.
This type is declared in WinNT.h as follows:
typedef LONG HRESULT;
HRGN	
A handle to a region.
This type is declared in WinDef.h as follows:
typedef HANDLE HRGN;
HRSRC	
A handle to a resource.
This type is declared in WinDef.h as follows:
typedef HANDLE HRSRC;
HSZ	
A handle to a DDE string.
This type is declared in Ddeml.h as follows:
typedef HANDLE HSZ;
HWINSTA	
A handle to a window station.
This type is declared in WinDef.h as follows:
typedef HANDLE WINSTA;
HWND	
A handle to a window.
This type is declared in WinDef.h as follows:
typedef HANDLE HWND;
INT	
A 32-bit signed integer. The range is -2147483648 through 2147483647 decimal.
This type is declared in WinDef.h as follows:
typedef int INT;
INT_PTR	
A signed integer type for pointer precision. Use when casting a pointer to an integer to perform pointer arithmetic.
This type is declared in BaseTsd.h as follows:
C++

#if defined(_WIN64) 
 typedef __int64 INT_PTR; 
#else 
 typedef int INT_PTR;
#endif

INT8	
An 8-bit signed integer.
This type is declared in BaseTsd.h as follows:
typedef signed char INT8;
INT16	
A 16-bit signed integer.
This type is declared in BaseTsd.h as follows:
typedef signed short INT16;
INT32	
A 32-bit signed integer. The range is -2147483648 through 2147483647 decimal.
This type is declared in BaseTsd.h as follows:
typedef signed int INT32;
INT64	
A 64-bit signed integer. The range is C9223372036854775808 through 9223372036854775807 decimal.
This type is declared in BaseTsd.h as follows:
typedef signed __int64 INT64;
LANGID	
A language identifier. For more information, see Language Identifiers.
This type is declared in WinNT.h as follows:
typedef WORD LANGID;
LCID	
A locale identifier. For more information, see Locale Identifiers.
This type is declared in WinNT.h as follows:
typedef DWORD LCID;
LCTYPE	
A locale information type. For a list, see Locale Information Constants.
This type is declared in WinNls.h as follows:
typedef DWORD LCTYPE;
LGRPID	
A language group identifier. For a list, see EnumLanguageGroupLocales.
This type is declared in WinNls.h as follows:
typedef DWORD LGRPID;
LONG	
A 32-bit signed integer. The range is C2147483648 through 2147483647 decimal.
This type is declared in WinNT.h as follows:
typedef long LONG;
LONGLONG	
A 64-bit signed integer. The range is C9223372036854775808 through 9223372036854775807 decimal.
This type is declared in WinNT.h as follows:
C++

#if !defined(_M_IX86)
 typedef __int64 LONGLONG; 
#else
 typedef double LONGLONG;
#endif

LONG_PTR	
A signed long type for pointer precision. Use when casting a pointer to a long to perform pointer arithmetic.
This type is declared in BaseTsd.h as follows:
C++

#if defined(_WIN64)
 typedef __int64 LONG_PTR; 
#else
 typedef long LONG_PTR;
#endif

LONG32	
A 32-bit signed integer. The range is C2147483648 through 2147483647 decimal.
This type is declared in BaseTsd.h as follows:
typedef signed int LONG32;
LONG64	
A 64-bit signed integer. The range is C9223372036854775808 through 9223372036854775807 decimal.
This type is declared in BaseTsd.h as follows:
typedef __int64 LONG64;
LPARAM	
A message parameter.
This type is declared in WinDef.h as follows:
typedef LONG_PTR LPARAM;
LPBOOL	
A pointer to a BOOL.
This type is declared in WinDef.h as follows:
typedef BOOL far *LPBOOL;
LPBYTE	
A pointer to a BYTE.
This type is declared in WinDef.h as follows:
typedef BYTE far *LPBYTE;
LPCOLORREF	
A pointer to a COLORREF value.
This type is declared in WinDef.h as follows:
typedef DWORD *LPCOLORREF;
LPCSTR	
A pointer to a constant null-terminated string of 8-bit Windows (ANSI) characters. For more information, see Character Sets Used By Fonts.
This type is declared in WinNT.h as follows:
typedef __nullterminated CONST CHAR *LPCSTR;
LPCTSTR	
An LPCWSTR if UNICODE is defined, an LPCSTR otherwise. For more information, see Windows Data Types for Strings.
This type is declared in WinNT.h as follows:
C++

#ifdef UNICODE
 typedef LPCWSTR LPCTSTR; 
#else
 typedef LPCSTR LPCTSTR;
#endif

LPCVOID	
A pointer to a constant of any type.
This type is declared in WinDef.h as follows:
typedef CONST void *LPCVOID;
LPCWSTR	
A pointer to a constant null-terminated string of 16-bit Unicode characters. For more information, see Character Sets Used By Fonts.
This type is declared in WinNT.h as follows:
typedef CONST WCHAR *LPCWSTR;
LPDWORD	
A pointer to a DWORD.
This type is declared in WinDef.h as follows:
typedef DWORD *LPDWORD;
LPHANDLE	
A pointer to a HANDLE.
This type is declared in WinDef.h as follows:
typedef HANDLE *LPHANDLE;
LPINT	
A pointer to an INT.
This type is declared in WinDef.h as follows:
typedef int *LPINT;
LPLONG	
A pointer to a LONG.
This type is declared in WinDef.h as follows:
typedef long *LPLONG;
LPSTR	
A pointer to a null-terminated string of 8-bit Windows (ANSI) characters. For more information, see Character Sets Used By Fonts.
This type is declared in WinNT.h as follows:
typedef CHAR *LPSTR;
LPTSTR	
An LPWSTR if UNICODE is defined, an LPSTR otherwise. For more information, see Windows Data Types for Strings.
This type is declared in WinNT.h as follows:
C++

#ifdef UNICODE
 typedef LPWSTR LPTSTR;
#else
 typedef LPSTR LPTSTR;
#endif

LPVOID	
A pointer to any type.
This type is declared in WinDef.h as follows:
typedef void *LPVOID;
LPWORD	
A pointer to a WORD.
This type is declared in WinDef.h as follows:
typedef WORD *LPWORD;
LPWSTR	
A pointer to a null-terminated string of 16-bit Unicode characters. For more information, see Character Sets Used By Fonts.
This type is declared in WinNT.h as follows:
typedef WCHAR *LPWSTR;
LRESULT	
Signed result of message processing.
This type is declared in WinDef.h as follows:
typedef LONG_PTR LRESULT;
PBOOL	
A pointer to a BOOL.
This type is declared in WinDef.h as follows:
typedef BOOL *PBOOL;
PBOOLEAN	
A pointer to a BOOLEAN.
This type is declared in WinNT.h as follows:
typedef BOOLEAN *PBOOLEAN;
PBYTE	
A pointer to a BYTE.
This type is declared in WinDef.h as follows:
typedef BYTE *PBYTE;
PCHAR	
A pointer to a CHAR.
This type is declared in WinNT.h as follows:
typedef CHAR *PCHAR;
PCSTR	
A pointer to a constant null-terminated string of 8-bit Windows (ANSI) characters. For more information, see Character Sets Used By Fonts.
This type is declared in WinNT.h as follows:
typedef CONST CHAR *PCSTR;
PCTSTR	
A PCWSTR if UNICODE is defined, a PCSTR otherwise. For more information, see Windows Data Types for Strings.
This type is declared in WinNT.h as follows:
C++

#ifdef UNICODE
 typedef LPCWSTR PCTSTR;
#else
 typedef LPCSTR PCTSTR;
#endif

PCWSTR	
A pointer to a constant null-terminated string of 16-bit Unicode characters. For more information, see Character Sets Used By Fonts.
This type is declared in WinNT.h as follows:
typedef CONST WCHAR *PCWSTR;
PDWORD	
A pointer to a DWORD.
This type is declared in WinDef.h as follows:
typedef DWORD *PDWORD;
PDWORDLONG	
A pointer to a DWORDLONG.
This type is declared in WinNT.h as follows:
typedef DWORDLONG *PDWORDLONG;
PDWORD_PTR	
A pointer to a DWORD_PTR.
This type is declared in BaseTsd.h as follows:
typedef DWORD_PTR *PDWORD_PTR;
PDWORD32	
A pointer to a DWORD32.
This type is declared in BaseTsd.h as follows:
typedef DWORD32 *PDWORD32;
PDWORD64	
A pointer to a DWORD64.
This type is declared in BaseTsd.h as follows:
typedef DWORD64 *PDWORD64;
PFLOAT	
A pointer to a FLOAT.
This type is declared in WinDef.h as follows:
typedef FLOAT *PFLOAT;
PHALF_PTR	
A pointer to a HALF_PTR.
This type is declared in BaseTsd.h as follows:
C++

#ifdef _WIN64
 typedef HALF_PTR *PHALF_PTR;
#else
 typedef HALF_PTR *PHALF_PTR;
#endif

PHANDLE	
A pointer to a HANDLE.
This type is declared in WinNT.h as follows:
typedef HANDLE *PHANDLE;
PHKEY	
A pointer to an HKEY.
This type is declared in WinDef.h as follows:
typedef HKEY *PHKEY;
PINT	
A pointer to an INT.
This type is declared in WinDef.h as follows:
typedef int *PINT;
PINT_PTR	
A pointer to an INT_PTR.
This type is declared in BaseTsd.h as follows:
typedef INT_PTR *PINT_PTR;
PINT8	
A pointer to an INT8.
This type is declared in BaseTsd.h as follows:
typedef INT8 *PINT8;
PINT16	
A pointer to an INT16.
This type is declared in BaseTsd.h as follows:
typedef INT16 *PINT16;
PINT32	
A pointer to an INT32.
This type is declared in BaseTsd.h as follows:
typedef INT32 *PINT32;
PINT64	
A pointer to an INT64.
This type is declared in BaseTsd.h as follows:
typedef INT64 *PINT64;
PLCID	
A pointer to an LCID.
This type is declared in WinNT.h as follows:
typedef PDWORD PLCID;
PLONG	
A pointer to a LONG.
This type is declared in WinNT.h as follows:
typedef LONG *PLONG;
PLONGLONG	
A pointer to a LONGLONG.
This type is declared in WinNT.h as follows:
typedef LONGLONG *PLONGLONG;
PLONG_PTR	
A pointer to a LONG_PTR.
This type is declared in BaseTsd.h as follows:
typedef LONG_PTR *PLONG_PTR;
PLONG32	
A pointer to a LONG32.
This type is declared in BaseTsd.h as follows:
typedef LONG32 *PLONG32;
PLONG64	
A pointer to a LONG64.
This type is declared in BaseTsd.h as follows:
typedef LONG64 *PLONG64;
POINTER_32	
A 32-bit pointer. On a 32-bit system, this is a native pointer. On a 64-bit system, this is a truncated 64-bit pointer.
This type is declared in BaseTsd.h as follows:
C++

#if defined(_WIN64)
 #define POINTER_32 __ptr32
#else
 #define POINTER_32
#endif

POINTER_64	
A 64-bit pointer. On a 64-bit system, this is a native pointer. On a 32-bit system, this is a sign-extended 32-bit pointer.
Note that it is not safe to assume the state of the high pointer bit.
This type is declared in BaseTsd.h as follows:
C++

#if (_MSC_VER >= 1300)
 #define POINTER_64 __ptr64
#else
 #define POINTER_64
#endif

POINTER_SIGNED	
A signed pointer.
This type is declared in BaseTsd.h as follows:
#define POINTER_SIGNED __sptr
POINTER_UNSIGNED	
An unsigned pointer.
This type is declared in BaseTsd.h as follows:
#define POINTER_UNSIGNED __uptr
PSHORT	
A pointer to a SHORT.
This type is declared in WinNT.h as follows:
typedef SHORT *PSHORT;
PSIZE_T	
A pointer to a SIZE_T.
This type is declared in BaseTsd.h as follows:
typedef SIZE_T *PSIZE_T;
PSSIZE_T	
A pointer to a SSIZE_T.
This type is declared in BaseTsd.h as follows:
typedef SSIZE_T *PSSIZE_T;
PSTR	
A pointer to a null-terminated string of 8-bit Windows (ANSI) characters. For more information, see Character Sets Used By Fonts.
This type is declared in WinNT.h as follows:
typedef CHAR *PSTR;
PTBYTE	
A pointer to a TBYTE.
This type is declared in WinNT.h as follows:
typedef TBYTE *PTBYTE;
PTCHAR	
A pointer to a TCHAR.
This type is declared in WinNT.h as follows:
typedef TCHAR *PTCHAR;
PTSTR	
A PWSTR if UNICODE is defined, a PSTR otherwise. For more information, see Windows Data Types for Strings.
This type is declared in WinNT.h as follows:
C++

#ifdef UNICODE
 typedef LPWSTR PTSTR;
#else typedef LPSTR PTSTR;
#endif

PUCHAR	
A pointer to a UCHAR.
This type is declared in WinDef.h as follows:
typedef UCHAR *PUCHAR;
PUHALF_PTR	
A pointer to a UHALF_PTR.
This type is declared in BaseTsd.h as follows:
C++

#ifdef _WIN64
 typedef UHALF_PTR *PUHALF_PTR;
#else
 typedef UHALF_PTR *PUHALF_PTR;
#endif

PUINT	
A pointer to a UINT.
This type is declared in WinDef.h as follows:
typedef UINT *PUINT;
PUINT_PTR	
A pointer to a UINT_PTR.
This type is declared in BaseTsd.h as follows:
typedef UINT_PTR *PUINT_PTR;
PUINT8	
A pointer to a UINT8.
This type is declared in BaseTsd.h as follows:
typedef UINT8 *PUINT8;
PUINT16	
A pointer to a UINT16.
This type is declared in BaseTsd.h as follows:
typedef UINT16 *PUINT16;
PUINT32	
A pointer to a UINT32.
This type is declared in BaseTsd.h as follows:
typedef UINT32 *PUINT32;
PUINT64	
A pointer to a UINT64.
This type is declared in BaseTsd.h as follows:
typedef UINT64 *PUINT64;
PULONG	
A pointer to a ULONG.
This type is declared in WinDef.h as follows:
typedef ULONG *PULONG;
PULONGLONG	
A pointer to a ULONGLONG.
This type is declared in WinDef.h as follows:
typedef ULONGLONG *PULONGLONG;
PULONG_PTR	
A pointer to a ULONG_PTR.
This type is declared in BaseTsd.h as follows:
typedef ULONG_PTR *PULONG_PTR;
PULONG32	
A pointer to a ULONG32.
This type is declared in BaseTsd.h as follows:
typedef ULONG32 *PULONG32;
PULONG64	
A pointer to a ULONG64.
This type is declared in BaseTsd.h as follows:
typedef ULONG64 *PULONG64;
PUSHORT	
A pointer to a USHORT.
This type is declared in WinDef.h as follows:
typedef USHORT *PUSHORT;
PVOID	
A pointer to any type.
This type is declared in WinNT.h as follows:
typedef void *PVOID;
PWCHAR	
A pointer to a WCHAR.
This type is declared in WinNT.h as follows:
typedef WCHAR *PWCHAR;
PWORD	
A pointer to a WORD.
This type is declared in WinDef.h as follows:
typedef WORD *PWORD;
PWSTR	
A pointer to a null-terminated string of 16-bit Unicode characters. For more information, see Character Sets Used By Fonts.
This type is declared in WinNT.h as follows:
typedef WCHAR *PWSTR;
QWORD	
A 64-bit unsigned integer.
This type is declared as follows:
typedef unsigned __int64 QWORD;
SC_HANDLE	
A handle to a service control manager database. For more information, see SCM Handles.
This type is declared in WinSvc.h as follows:
typedef HANDLE SC_HANDLE;
SC_LOCK	
A lock to a service control manager database. For more information, see SCM Handles.
This type is declared in WinSvc.h as follows:
typedef LPVOID SC_LOCK;
SERVICE_STATUS_HANDLE	
A handle to a service status value. For more information, see SCM Handles.
This type is declared in WinSvc.h as follows:
typedef HANDLE SERVICE_STATUS_HANDLE;
SHORT	
A 16-bit integer. The range is C32768 through 32767 decimal.
This type is declared in WinNT.h as follows:
typedef short SHORT;
SIZE_T	
The maximum number of bytes to which a pointer can point. Use for a count that must span the full range of a pointer.
This type is declared in BaseTsd.h as follows:
typedef ULONG_PTR SIZE_T;
SSIZE_T	
A signed version of SIZE_T.
This type is declared in BaseTsd.h as follows:
typedef LONG_PTR SSIZE_T;
TBYTE	
A WCHAR if UNICODE is defined, a CHAR otherwise.
This type is declared in WinNT.h as follows:
C++

#ifdef UNICODE
 typedef WCHAR TBYTE;
#else
 typedef unsigned char TBYTE;
#endif

TCHAR	
A WCHAR if UNICODE is defined, a CHAR otherwise.
This type is declared in WinNT.h as follows:
C++

#ifdef UNICODE
 typedef WCHAR TCHAR;
#else
 typedef char TCHAR;
#endif

UCHAR	
An unsigned CHAR.
This type is declared in WinDef.h as follows:
typedef unsigned char UCHAR;
UHALF_PTR	
An unsigned HALF_PTR. Use within a structure that contains a pointer and two small fields.
This type is declared in BaseTsd.h as follows:
C++

#ifdef _WIN64
 typedef unsigned int UHALF_PTR;
#else
 typedef unsigned short UHALF_PTR;
#endif

UINT	
An unsigned INT. The range is 0 through 4294967295 decimal.
This type is declared in WinDef.h as follows:
typedef unsigned int UINT;
UINT_PTR	
An unsigned INT_PTR.
This type is declared in BaseTsd.h as follows:
C++

#if defined(_WIN64)
 typedef unsigned __int64 UINT_PTR;
#else
 typedef unsigned int UINT_PTR;
#endif

UINT8	
An unsigned INT8.
This type is declared in BaseTsd.h as follows:
typedef unsigned char UINT8;
UINT16	
An unsigned INT16.
This type is declared in BaseTsd.h as follows:
typedef unsigned short UINT16;
UINT32	
An unsigned INT32. The range is 0 through 4294967295 decimal.
This type is declared in BaseTsd.h as follows:
typedef unsigned int UINT32;
UINT64	
An unsigned INT64. The range is 0 through 18446744073709551615 decimal.
This type is declared in BaseTsd.h as follows:
typedef usigned __int 64 UINT64;
ULONG	
An unsigned LONG. The range is 0 through 4294967295 decimal.
This type is declared in WinDef.h as follows:
typedef unsigned long ULONG;
ULONGLONG	
A 64-bit unsigned integer. The range is 0 through 18446744073709551615 decimal.
This type is declared in WinNT.h as follows:
C++

#if !defined(_M_IX86)
 typedef unsigned __int64 ULONGLONG;
#else
 typedef double ULONGLONG;
#endif

ULONG_PTR	
An unsigned LONG_PTR.
This type is declared in BaseTsd.h as follows:
C++

#if defined(_WIN64)
 typedef unsigned __int64 ULONG_PTR;
#else
 typedef unsigned long ULONG_PTR;
#endif

ULONG32	
An unsigned LONG32. The range is 0 through 4294967295 decimal.
This type is declared in BaseTsd.h as follows:
typedef unsigned int ULONG32;
ULONG64	
An unsigned LONG64. The range is 0 through 18446744073709551615 decimal.
This type is declared in BaseTsd.h as follows:
typedef unsigned __int64 ULONG64;
UNICODE_STRING	
A Unicode string.
This type is declared in Winternl.h as follows:
C++

typedef struct _UNICODE_STRING {
  USHORT  Length;
  USHORT  MaximumLength;
  PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;

USHORT	
An unsigned SHORT. The range is 0 through 65535 decimal.
This type is declared in WinDef.h as follows:
typedef unsigned short USHORT;
USN	
An update sequence number (USN).
This type is declared in WinNT.h as follows:
typedef LONGLONG USN;
VOID	
Any type.
This type is declared in WinNT.h as follows:
#define VOID void
WCHAR	
A 16-bit Unicode character. For more information, see Character Sets Used By Fonts.
This type is declared in WinNT.h as follows:
typedef wchar_t WCHAR;
WINAPI	
The calling convention for system functions.
This type is declared in WinDef.h as follows:
#define WINAPI __stdcall
CALLBACK, WINAPI, and APIENTRY are all used to define functions with the __stdcall calling convention. Most functions in the Windows API are declared using WINAPI. You may wish to use CALLBACK for the callback functions that you implement to help identify the function as a callback function.
WORD	
A 16-bit unsigned integer. The range is 0 through 65535 decimal.
This type is declared in WinDef.h as follows:
typedef unsigned short WORD;
WPARAM	
A message parameter.
This type is declared in WinDef.h as follows:
typedef UINT_PTR WPARAM;
Requirements
Minimum supported client
Windows XP [desktop apps only]
Minimum supported server
Windows Server 2003 [desktop apps only]
Header
BaseTsd.h;
WinDef.h;
WinNT.h
 
 
Send comments about this topic to Microsoft
Build date: 10/16/2012
Did you find this helpful?  Yes  No
Community Additions
ADD
Visual Basic 9 Equivalents for PInvoke

MSDN Type Visual Basic 9 Type

ATOM UShort
BOOL Integer
BOOLEAN Byte
BYTE Byte
CALLBACK Delegate
CHAR SByte
COLORREF UInteger
CONST Const
DWORD UInteger
DWORDLONG ULong
DWORD_PTR UInteger (ULong)
DWORD32 UInteger
DWORD64 Long
FLOAT Single
HACCEL IntPtr
HALF_PTR Short (Integer)
HANDLE IntPtr
HBITMAP IntPtr
HBRUSH IntPtr
HCONV IntPtr
HCONVLIST IntPtr
HCURSOR IntPtr
HDC IntPtr
HDDEDATA IntPtr
HDESK IntPtr
HDROP IntPtr
HDWP IntPtr
HENHMETAFILE IntPtr
HFILE Integer
HFONT IntPtr
HGIDOBJ IntPtr
HGLOBAL IntPtr
HHOOK IntPtr
HICON IntPtr
HINSTANCE IntPtr
HKEY IntPtr
HKL IntPtr
HLOCAL IntPtr
HMENU IntPtr
HMETAFILE IntPtr
HMODULE IntPtr
HMONITOR IntPtr
HPALETTE IntPtr
HPEN IntPtr
HRESULT Integer
HRGN IntPtr
HRSRC IntPtr
HSZ IntPtr
HWINSTA IntPtr
HWND IntPtr
INT_PTR Integer (Long)
INT32 Integer
INT64 Long
LANGID UShort
LCID UInteger
LGRPID UInteger
LONG Integer
LONGLONG Long
LONG_PTR Integer (Long)
LONG32 Integer
LONG64 Long
LPARAM Integer (Long)
LPBOOL ByRef Integer
LPBYTE ByRef Byte
LPCOLORREF UInteger
LPCSTR ByRef SByte
LPCTSTR ByRef Char
LPCWSTR ByRef Char
LPDWORD UInteger
LPHANDLE ByRef IntPtr
LPINT Integer (Long)
LPLONG Integer
LPSTR ByRef SByte
LPTSTR ByRef Char
LPVOID IntPtr
LPWORD UShort
LPWSTR ByRef Char
LRESULT Integer (Long)
PBOOL Integer (Long)
PBOOLEAN ByRef Byte
PBYTE ByRef Byte
PCHAR ByRef SByte
PCSTR ByRef SByte
PCTSTR ByRef Char
PCWSTR ByRef Char
PDWORD UInteger
PDWORDLONG ByRef ULong
PDWORD_PTR ByRef UInteger (ULong)
PDWORD32 ByRef UInteger
PDWORD64 ByRef Long
PFLOAT ByRef Single
PHALF_PTR ByRef Short (Integer)
PHANDLE ByRef IntPtr
PHKEY ByRef IntPtr
PINT Integer (Long)
PINT_PTR ByRef Integer (Long)
PINT32 ByRef Integer
PINT64 ByRef Long
PLCID UInteger
PLONG Integer
PLONGLONG ByRef Long
PLONG_PTR ByRef Integer (Long)
PLONG32 ByRef Integer
PLONG64 ByRef Long
POINTER_32 (IntPtr)
POINTER_64 IntPtr
POINTER_SIGNED IntPtr
POINTER_UNSIGNED UIntPtr
PSHORT Short
PSIZE_T ByRef UInteger (ULong)
PSSIZE_T ByRef Integer (Long)
PSTR ByRef SByte
PTBYTE ByRef Char
PTCHAR ByRef Char
PTSTR ByRef Char
PUCHAR ByRef Byte
PUHALF_PTR ByRef UShort (UInteger)
PUINT ByRef UInteger
PUINT_PTR ByRef UInteger (ULong)
PUINT32 ByRef UInteger
PUINT64 ByRef ULong
PULONG UInteger
PULONGLONG ByRef ULong
PULONG_PTR ByRef UInteger (ULong)
PULONG32 ByRef UInteger
PULONG64 ByRef ULong
PUSHORT UShort
PVOID IntPtr
PWCHAR ByRef Char
PWORD UShort
PWSTR ByRef Char
SC_HANDLE IntPtr
SC_LOCK IntPtr
SERVICE_STATUS_HANDLE IntPtr
SHORT Short
SIZE_T UInteger (ULong)
SSIZE_T Integer (Long)
TBYTE Char
TCHAR Char
UCHAR Byte
UHALF_PTR UShort (UInteger)
UINT UInteger
UINT_PTR UInteger (ULong)
UINT32 UInteger
UINT64 ULong
ULONG UInteger
ULONGLONG ULong
ULONG_PTR UInteger (ULong)
ULONG32 UInteger
ULONG64 ULong
UNICODE_STRING Structure UNICODE_STRING : Dim Lenght As UShort, MaximumLenght As UShort, ByRef Buffer As Char : End Structure
USHORT UShort
USN Long
VOID Object
WCHAR Char
WIANPI Delegate
WORD UShort
WPARAM UInteger (ULong)

2 types means 32bit plaform (64bit platform)
Assumes #Unicode directive
Assumest highest Windows version possible

See full table http://spreadsheets.google.com/ccc?key=pK5CEcdG9GYGeO7K2dmEcBg

yic81
10/7/2012
LONGLONG - defined via double?


LONGLONG

64-bit signed integer.
The range is C9223372036854775808 through 9223372036854775807 decimal.

This type is declared in WinNT.h as follows:



#if !defined(_M_IX86)


typedef __int64 LONGLONG; 


#else

typedef double LONGLONG;

#endif

Is it in above is typing error?

The datatype "double" is defined: 

Type double is a floating type that is larger than or equal to type float, but shorter than or equal to the size of type longdouble.1

yic81
10/7/2012
This article needs reviewing
When was it last reviewed? 15 years ago?
The statement typedef HANDLE HINSTANCE; is totally incorrect, as many other typedef HANDLEs. Vast majority of them are now DECLARE_HANDLE() structs. Please review and fix this article. 

yic81
10/7/2012
DOUBLE and CY are undocumented
The types DOUBLE and CY are undocumented here, although their existence is attested by the documentation page for VARIANT.

The type CY is defined aside with CURRENCY instead.

yic81
10/7/2012
DOUBLE and CY are undocumented
The types DOUBLE and CY are undocumented here, although their existence is attested by the documentation page for VARIANT.

The type CY is defined aside with CURRENCY instead.

yic81
10/7/2012
qword isn't defined
Apparently, QWORD isn't defined in any of the windows header files for MSVC 2010.

yic81
10/7/2012
HWND can't be read
Note that
though HWND is a "pointer to void *"
or (in the VBasic example) an IntPtr (pointer to an int).  So size of a pointer.

you can't actually read the value it "is a pointer to," or write to that location. It's just a pointer into some deep dark windows data structure, and the fact that it points into that exact location is all it gives you. You'll get a memory read exception if you try to read from that location.

yic81
10/7/2012
Network sites
 
Windows Dev Center
Windows Dev Center home
Windows Store apps
Internet Explorer
Desktop
Hardware
Other links
Support
Microsoft Connect
Windows Phone Dev Center







wcslen
_wfopen

swcard data sample:
;6225882013142259=49121202531300105614?+996225882013142259=1561560500050000001015105614214000049120=2013142259=000000000=04000000020000000000000?
  

vs ide ce console app entry point: "" or mainWCRTStartup
mfc app: WinMainCRTStartup; wWinMainCRTStartup


09:51 2012-12-25
   _Out_opt_
   

这两天抽时间又总结/整理了一下各种编码的实际编码方式，和在Java应用中的使用情况，在这里记录下来以便日后参考。
为了构成一个完整的对文字编码的认识和深入把握，以便处理在Java开发过程中遇到的各种问题，特别是乱码问题，我觉得组成一个系列来描述和分析更好一些，包括三篇文章：
第一篇：JAVA字符编码系列一：Unicode,GBK,GB2312,UTF-8概念基础
第二篇：JAVA字符编码系列二：Unicode,ISO-8859,GBK,UTF-8编码及相互转换
第三篇：JAVA字符编码系列三：Java应用中的编码问题
 
第一篇：JAVA字符编码系列一：Unicode,GBK,GB2312,UTF-8概念基础
本部分采用重用，转载一篇文章来完成这部分的目标。
来源：holen'blog   对字符编码与Unicode,ISO 10646,UCS,UTF8,UTF16,GBK,GB2312的理解
地址：http://blog.donews.com/holen/archive/2004/11/30/188182.aspx
 
Unicode: 

unicode.org制定的编码机制, 要将全世界常用文字都函括进去.
在1.0中是16位编码, 由U+0000到U+FFFF. 每个2byte码对应一个字符; 在2.0开始抛弃了16位限制, 原来的16位作为基本位平面, 另外增加了16个位平面, 相当于20位编码, 编码范围0到0x10FFFF.

UCS: 

ISO制定的ISO10646标准所定义的 Universal Character Set, 采用4byte编码.

Unicode与UCS的关系:

ISO与unicode.org是两个不同的组织, 因此最初制定了不同的标准; 但自从unicode2.0开始, unicode采用了与ISO 10646-1相同的字库和字码, ISO也承诺ISO10646将不会给超出0x10FFFF的UCS-4编码赋值, 使得两者保持一致.

UCS的编码方式:


UCS-2, 与unicode的2byte编码基本一样. 

UCS-4, 4byte编码, 目前是在UCS-2前加上2个全零的byte.

UTF: Unicode/UCS Transformation Format

UTF-8, 8bit编码, ASCII不作变换, 其他字符做变长编码, 每个字符1-3 byte. 通常作为外码. 有以下优点:
* 与CPU字节顺序无关, 可以在不同平台之间交流
* 容错能力高, 任何一个字节损坏后, 最多只会导致一个编码码位损失, 不会链锁错误(如GB码错一个字节就会整行乱码) 

UTF-16, 16bit编码, 是变长码, 大致相当于20位编码, 值在0到0x10FFFF之间, 基本上就是unicode编码的实现. 它是变长码, 与CPU字序有关, 但因为最省空间, 常作为网络传输的外码.
UTF-16是unicode的preferred encoding. 

UTF-32, 仅使用了unicode范围(0到0x10FFFF)的32位编码, 相当于UCS-4的子集.

UTF与unicode的关系:

Unicode是一个字符集, 可以看作为内码.
而UTF是一种编码方式, 它的出现是因为unicode不适宜在某些场合直接传输和处理. UTF-16直接就是unicode编码, 没有变换, 但它包含了0x00在编码内, 头256字节码的第一个byte都是0x00, 在操作系统(C语言)中有特殊意义, 会引起问题. 采用UTF-8编码对unicode的直接编码作些变换可以避免这问题, 并带来一些优点.

中国国标编码:

GB 13000: 完全等同于ISO 10646-1/Unicode 2.1, 今后也将随ISO 10646/Unicode的标准更改而同步更改.

GBK: 对GB2312的扩充, 以容纳GB2312字符集范围以外的Unicode 2.1的统一汉字部分, 并且增加了部分unicode中没有的字符. 

GB 18030-2000: 基于GB 13000, 作为Unicode 3.0的GBK扩展版本, 覆盖了所有unicode编码, 地位等同于UTF-8, UTF-16, 是一种unicode编码形式. 变长编码, 用单字节/双字节/4字节对字符编码. GB18030向下兼容GB2312/GBK. 
GB 18030是中国所有非手持/嵌入式计算机系统的强制实施标准. 



QByteArray QString::toLocal8Bit () const
Returns the local 8-bit representation of the string as a QByteArray. The returned byte array is undefined if the string contains characters not supported by the local 8-bit encoding.
QTextCodec::codecForLocale() is used to perform the conversion from Unicode. If the locale encoding could not be determined, this function does the same as toLatin1().
If this string contains any characters that cannot be encoded in the locale, the returned byte array is undefined. Those characters may be suppressed or replaced by another.










15:23 2013-01-02
   schroot -c mx515
   scp [file] root@10.10.151.183:/usr/tmp
   rz sz

   export DISPLAY=:0.0
   


22:20 2013-01-06
   killall wpa_supplicant
  iwconfig wlan0 essid off
   wpa_supplicant -B -iwlan0 -c /usr/Fn/data/user.data/libwireless_manager/wpa_supplicant.conf





ifconfig wlan0 up 192.168.0.222
ifconfig wlan0 netmask 255.255.255.0
sleep 1
route add default gw 192.168.0.1 wlan0


dhclient
   





21:55 2013-01-07
   Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
   192.168.11.0    0.0.0.0         255.255.255.0   U     0      0        0 eth0
   0.0.0.0         192.168.11.1    0.0.0.0         UG    100    0        0 eth0



14:53 2013-01-08
   the window wins dependence on "workstation" and "server" service
   


When the user connects to a remote VisualSVN Server using the management console, the server uses the current credentials to authenticate the user. All administrative actions on the remote server are performed on the user's behalf. In other words, VisualSVN Server impersonates the user. This requires that user account should have appropriate permissions on the remote computer where VisualSVN Server is installed. This article describes how to configure these permissions properly. 

Incorrect user access rights settings are usually identified by receiving the "Access is denied" error message when trying to connect to VisualSVN Server remotely: 

Cannot connect to WMI namespace '\\server-2008\root\VisualSVN': Access is denied. (0x80070005) 
Configuration steps described in this article apply to domain and non-domain environments. However, the server may require you to perform additional configuration steps in a non-domain environment. 

The following permissions are required to administer VisualSVN Server remotely: 

Permissions to access DCOM and WMI remotely, 
Special permissions to manage resources related to VisualSVN Server. 

Users who are local administrators on the computer where VisualSVN Server is installed automatically obtain all required permissions to administer the server remotely. 

To grant all the required permission to a non-administrative user, you should include the user in the following local groups on the computer where VisualSVN Server is installed: 

VisualSVN Server Admins, 
Distributed COM Users. 






Please note that there is just one download for both versions of VisualSVN Server (Enterprise and Standard). The license key unlocks the additional features offered in the Enterprise Edition.

Step 2: Enter evaluation key
After downloading and installing VisualSVN Server, you need to input the evaluation key (see below), which will temporarily unlock the Enterprise Edition features.

Entering the evaluation key:

Here is your evaluation license key. After the 45-day trial period, VisualSVN Server Enterprise Edition will revert to Standard Edition.

11:39 2013-01-09
netsh interface ip set address name="本地连接" static 10.20.30.202 255.255.255.0  10.20.30.1 1






23:55 2013-01-12
   1:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC02ODEuYXZpfDE1Mjc1ODY5NzJ8OUZDRkZDRjJBNjkwRTU3RkJGNDk5Rjc4Q0IzQzE3NDR8L1pa


2:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC02NjEuYXZpfDEyOTAxNDgzNTJ8NzVCQjFDOTRCNUVDQ0U1N0M0RDdFMThEMzc1OURCNUN8L1pa


3:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC02MzUuYXZpfDE1NDI0NjQ0MTJ8RDUyRjM3NUI2ODAzMzA0NjAzMTNEMzk2OUVGNUIwRUF8L1pa


4:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC02MjUuYXZpfDEyODgyMTA0Mjl8QjdBQ0EwODY3QjZGQzNFNEQ3RjFEQjUyRTFGOUY1REN8L1pa


5:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC02MDkuYXZpfDIwMzE2ODQ5MTZ8RTYxREVCOUQzNDVBODkxNDdDODU0RTMwRjRFNjAwQkV8L1pa


6:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC02MDEuYXZpfDE5MDQ3NTEyMDB8QjlCRUY0MThBNTJDQUQzQjQzMDg0QUY3MzVEQUFGMUJ8L1pa


7:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC01NzYuYXZpfDE1MDg2Mzg3MzR8MDE3MkNGRkEyQUNFOTMyMUQwMTAyMUExREYzNUJEMjF8L1pa


8:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC01NzAuYXZpfDE1MTQ2NjI5OTB8OTBFREExNzJCMEJCODFBQTlBNTYzN0I0QTRDRkM3RTR8L1pa


9:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC01NTMuYXZpfDE0NDc2ODQwOTZ8NENDM0UxMDAyOURGRkY4Q0MzNjUwMDRCRjc2NjJDQzh8L1pa


10:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC01NDAuYXZpfDE4OTAzNzEwNzJ8RkVEQjYwQjUzM0M0QjVBMTI3MDc2RjlFQTA0MTYwNUR8L1pa


11:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC01MzAuYXZpfDE4NzcwOTAxOTV8MEJBMUNDOTFCRDQxRDJCMkU3REU4RkU5QUQ4NDU0OTR8L1pa


12:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC01MjMuYXZpfDEzMjUyNDc1NzF8QkQ4Q0Q1RDM5NjU2MzVFMzhCMTAxN0ZCRUI3RDYxODN8L1pa


13:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC01MDguYXZpfDE3NzI5NjEyODB8RkU2NkEyNDREMzdDRkFCODI0RjYxQkUwNUNEMDA4RUJ8L1pa


14:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC00OTYuYXZpfDEzNDk5NjMyNzh8MkRBQkQ0NzgzRjdGQjI1QjA3NzYyNUNCMTcwMUU3NDB8L1pa


15:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC00ODkuYXZpfDE3MDMwMzU5MDR8MzNCOTU1NTE5NjNDM0U1RkI4ODQ3RTc3NkQxNkExQzh8L1pa


16:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC00NzYuYXZpfDE4ODAwOTMxODR8RUFGRDY2NEFEMkNFRTI5MDc5QjdFRjU1Mjg2NDZBQkJ8L1pa


17:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC00NjYuYXZpfDE3NDc2MDYwMTZ8OTRBODMwQTJDRUUyMENEN0Q3MDUzMDBDMzhCQUMzRjl8L1pa


18:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC00NjAuYXZpfDEyNzY3ODkyNDh8RTc1MTFGMUMwRTU4REFDNDgwNzZFQkM1NDkwNjBDRkZ8L1pa


19:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC00NDYuYXZpfDE3MjQwNzg1OTJ8RkYyQjUzRkY1MjFGRDVCNEFFNzQ2NUZBODQyRDYzMkN8L1pa


20:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC00NDIuYXZpfDE4MDI4NTQ0MDB8OThEM0ZBOTE0QTNFMjVCNDE1QjE1QTRFMjE3REI0NDR8L1pa


21:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC00MzMuYXZpfDEyNzcxODE5NTJ8N0U0MzI3MEVDNzY2MENCQTQyMzkyQUJBRjQ4MjZBMUR8L1pa


22:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC00MjcuYXZpfDE3OTExMDc1ODR8NUI5Q0JCMTE2OTQwQzBBOUM0QTk2M0E3NzgxMUUzMzd8L1pa


23:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC00MTQuYXZpfDEyNzc2NDQ4MDB8OENBRjFBNTFCMjFCMkNBMkFCQ0U1N0NFQTYyQjQzOEV8L1pa


24:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC00MDUuYXZpfDE3ODQzMjMwNzJ8MDdGNjYyMzlEODIyRUJDQTAzQzMzRDNFMzMxMEVEQTl8L1pa


25:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC0zOTMuYXZpfDEyOTY4MjUzNDR8RUM2MTg2RkZERDMzODE4NUVBN0M0OTM1MzNFNDQ4MkR8L1pa


26:thunder://QUFlZDJrOi8vfGZpbGV8SVBURC0zODUuYXZpfDEyNDgwOTIxNjB8OUEyMTFFMTk0NUJCQjFBRTRDQjVEMkQ0OUQ4Mjk5Rjd8L1pa
















错误	1	error LNK2005: "private: __thiscall type_info::type_info(class type_info const &)" (??0type_info@@AAE@ABV0@@Z) 已经在 LIBCMT.lib(typinfo.obj) 中定义	MSVCRTD.lib

ignore msvcrtd.lib






有无线电波、微波、红外线、可见光、紫外线、X射线和伽马射线

从波长长到短,分为:无线电波,红外线,可见光,紫外线,x射线和r射线
 
<<<<<<< .mine


sukisunyoyo(2013-01-27 12:28:59):

最新多看：http://bbs.duokan.com/forum/thread-77213-1-1.html
无法确认链接的安全性，请只打开来源可靠的网址

打开链接    
sukisunyoyo(2013-01-27 12:28:59):

最新多看：http://bbs.duokan.com/forum/thread-77213-1-1.html
sukisunyoyo(2013-01-27 12:29:01):

下载地址：
内容一：http://pan.baidu.com/share/link?shareid=158144&uk=402879370

内容二：http://pan.baidu.com/share/link?shareid=181408&uk=402879370

内容三：http://pan.baidu.com/share/link?shareid=181409&uk=402879370

内容四：http://pan.baidu.com/share/link?shareid=158147&uk=402879370





多看 for Kindle Paperwhite (系统版本号 5.2.0, 5.3.0, 5.3.1）
Kindle Paperwhite 简称 KP， 是内置光源的新一代触摸屏版本Kindle。
[两步安装法] 
1. 在Kindle原系统下，连接USB线到PC，拷贝1个文件夹和2个文件到Kindle磁盘。如下：
   DK_System 到 Kindle磁盘根目录
   MOBI8_DEBUG 到 Kindle磁盘根目录
   duokan.mobi 到 Kindle磁盘 的 documents 目录。
   然后弹出Kindle磁盘，断开USB线。直到在原系统能看见一本新书 《duokan 安装文档》。

2. 在原系统下打开 《duokan 安装文档》。
   在文档的中间看到Install按钮， 点击该按钮，按照屏幕上的提示进行安装。
说明：必须严格按照前面描述的步骤，先弹出Kindle磁盘，再拔USB线。


=======









字符 说明 示例 输出
C 货币 string.Format("{0:C3}", 2) ＄2.000 
D 十进制 string.Format("{0:D3}", 2) 002 
E 科学计数法 1.20E+001 1.20E+001 
G 常规 string.Format("{0:G}", 2) 2 
N 用分号隔开的数字 string.Format("{0:N}", 250000) 250,000.00 
X 十六进制 string.Format("{0:X000}", 12) C 

 
 string.Format("{0:000.000}", 12.2) 012.200 


编译器指示　<%@ 编译器指示 %>
声明　<%! 声明 %>
表达式 <%= 表达式 %>
程序代码段/小型指令　<% 程序代码片段 %>
注释　<%-- 注释 --%>


1、在网页中输出中文。JAVA在网络传输中使用的编码是"ISO-8859-1"，故在输出时需要进行转化，如：String str="中文";str=new String(str.getBytes("GB2312"),"8859_1");但假如在编译程序时，使用的编码是“GB2312”,且在中文平台上运行此程序，不会出现此问题，一定要注重。2、从参数中读取中文这正好与在网页中输出相反如：str=new String(str.getBytes("8859_1"),"GB2312");3、操作DB中的中文问题一个较简单的方法是：在“控制面扳”中，把“区域”设置为“英语(美国)”。假如还会出现乱码，还可进行如下设置：取中文时：str=new String(str.getBytes("GB2312"));向DB中输入中文：str=new String(str.getBytes("ISO-8859-1"));4、在jsp中的中文解决：在“控制面扳”中，把“区域”设置为“英语(美国)”.在JSP页面中加入：假如还不行正常显示，则还要进行下面的转换：如：name=new String(name.getBytes("ISO-8859-1"),"GBK");就不会出现中文问题了。

mount -o remount,rw rootfs /



同一操作作用于不同的类的实例，将产生不同的执行结果


1) 物理层: 	中继器，集线器，双绞线， 网卡
2）数据链路层:  网桥，二层交换机，网卡
3）网络层:      路由器，三层交换机	
4）传输层	四层路由器，交换机, rtp
5）应用层       SIP


1 有linux下c/c++，基于GTK的UI应用开发经验;熟悉linux下开发环境。接触过GtkWebkit，Wireless Tools;，SQL Sever, MySql数据库；热衷于网络编程，流媒体，游戏，有意向这方面发展。
2 有钻研精神，学习能力强；有良好的团队合作精神, 善于与人沟通；
3 通过大学英语四级考试；


----------------------------------------
int i = 1(258);
	char c = 0;

	c = i;
	printf("%d\n", c);

the result is: 
1(2)
----------------------------------------------

<<<<<<< .mine



find /etc -name source*





baidu: 119.75.218.70=======
<<<<<<< .mine

>>>>>>> .r1011



自旋锁适用情况

自旋锁比较适用于锁使用者保持锁时间比较短的情况。正是由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁。信号量和读写信号量适合于保持时间较长的情况，它们会导致调用者睡眠，因此只能在进程上下文使用，而自旋锁适合于保持时间非常短的情况，它可以在任何上下文使用。如果被保护的共享资源只在进程上下文访问，使用信号量保护该共享资源非常合适，如果对共享资源的访问时间非常短，自旋锁也可以。但是如果被保护的共享资源需要在中断上下文访问（包括底半部即中断处理句柄和顶半部即软中断），就必须使用自旋锁。自旋锁保持期间是抢占失效的，而信号量和读写信号量保持期间是可以被抢占的。自旋锁只有在内核可抢占或SMP（多处理器）的情况下才真正需要，在单CPU且不可抢占的内核下，自旋锁的所有操作都是空操作。另外格外注意一点：自旋锁不能递归使用。




信号量/互斥体和自旋锁的区别

信号量/互斥体允许进程睡眠属于睡眠锁，自旋锁则不允许调用者睡眠，而是让其循环等待，所以有以下区别应用 
    1）、信号量和读写信号量适合于保持时间较长的情况，它们会导致调用者睡眠，因而自旋锁适合于保持时间非常短的情况
    2）、自旋锁可以用于中断，不能用于进程上下文(会引起死锁)。而信号量不允许使用在中断中，而可以用于进程上下文
    3）、自旋锁保持期间是抢占失效的，自旋锁被持有时，内核不能被抢占，而信号量和读写信号量保持期间是可以被抢占的
   
另外需要注意的是
     1）、信号量锁保护的临界区可包含可能引起阻塞的代码，而自旋锁则绝对要避免用来保护包含这样代码的临界区，因为阻塞意味着要进行进程的切换，如果进程被切换出去后，另一进程企图获取本自旋锁，死锁就会发生。
     2）、在你占用信号量的同时不能占用自旋锁，因为在你等待信号量时可能会睡眠，而

在持有自旋锁时是不允许睡眠的。

 

 信号量和互斥体之间的区别

 

概念上的区别：      

      信号量：是进程间（线程间）同步用的，一个进程（线程）完成了某一个动作就通过信号量告诉别的进程（线程），别的进程（线程）再进行某些动作。有二值和多值信号量之分。

     互斥锁：是线程间互斥用的，一个线程占用了某一个共享资源，那么别的线程就无法访问，直到这个线程离开，其他的线程才开始可以使用这个共享资源。可以把互斥锁看成二值信号量。   

 
上锁时：

     信号量: 只要信号量的value大于0，其他线程就可以sem_wait成功，成功后信号量的value减一。若value值不大于0，则sem_wait阻塞，直到sem_post释放后value值加一。一句话，信号量的value>=0。

     互斥锁: 只要被锁住，其他任何线程都不可以访问被保护的资源。如果没有锁，获得资源成功，否则进行阻塞等待资源可用。一句话，线程互斥锁的vlaue可以为负数。   
 

使用场所：
     信号量主要适用于进程间通信，当然，也可用于线程间通信。而互斥锁只能用于线程间通信。


---------------------------------------------------------------------
svn: OPTIONS of 'https://server.domain.local/svn/repo': SSL handshake failed: SSL error:
Key usage violation in certificate has been detected. (https://server.domain.local) 


1.Add the following registry value to the Windows registry: 
for 32-bit system:

[HKEY_LOCAL_MACHINE\SOFTWARE\VisualSVN\VisualSVN Server]
"CreateGnuTLSCompatibleCertificate"=dword:00000001
      for 64-bit system:
    
[HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\VisualSVN\VisualSVN Server]
"CreateGnuTLSCompatibleCertificate"=dword:00000001
      2.Start VisualSVN Server Manager. 
3.Go to Action | Properties | Certificate. 
4.Click Change certificate... and follow the wizard instructions to generate a new self-signed certificate. 
   
--------------------------------------------------------------------------------------------------
   
      
kill gdm
      
   
vi jump to top: gg
   jump to bottom: G
         
   
-----------------------------------------------------------------aptitude
i	-	 包已经成功安装，并且所有依赖都满足.
c	-	 包已经被移除，但是配置文件被保留.
p	-	 包已经被删除，配置文件也被删除或者包没有被安装过.
v	-	 该软件包是虚拟的.
B	-	 该软件包的以来已经被损坏.
u	-	 软件包被解包（unpacked）但是没有被配置.
C	-	 半配置: 软件在配置时被打断.
H	-	 半安装: 包在安装的过程中被打断.
----------------------------------------------------------------------------         
   
mac addr size: 6 bytes

   
root@elon-desktop:/home/elon# file /sbin/init
/sbin/init: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.15, stripped


root@elon-desktop:/home/elon/open-source/myeclipse-9.0.0.M1-linux-gtk-x86_64# file myeclipse-installer 
myeclipse-installer: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.4.0, not strip		ped
   
java -jar xxx.jar

mount /dev/cdrom xxx(custom dir)
   
mysqladmin -uroot password root
   
create database test;
      
-------------------------
dd if=/dev/zero of=/opt/image/swap bs=1024 count=1024000

mkswap /opt/image/swap

swapon /opt/image/swap 

add the following statement for auto mounting:

/opt/image/swap none swap swape defaults 0       0
-----------------------------
       
tshark -i eth4 -T fields -e frame.number -e frame.time

				 -e tcp.srcport -e tcp.dstport
             
eclipse line num: ctr + F10 => “show line num"
   
      
char buf[10]: sizeof(buf)=10, int buf[10]: sizeof(buf)=10 * sizeof(int)
      	
         
win32:
echo %username%
   
linux shell:
jump to line-head： ctr + A / ctr + e
    
---------------------------------------
#include "string"
using namespace std;
    
string xxx;
---------------------------------------  

   
#include <sys/errno.h>

-------------------------------------------------------------------- mysql
mysql use a specific system user("mysql" default) for run but not the current shell user!!! and this user must have enough permission on some dir, such as  /var

use wildcard "%" at field "host" in the table "user" in database "mysql" for remote connection permission

#bind-address           = 127.0.0.1

--------------------------------------------------------------------   
   
[xuzhenjie@ud ~]$ perror 111
OS error code 111:  Connection refused



  
   



25.2.3.46. mysql_num_fields()
unsigned int mysql_num_fields(MYSQL_RES *result)
要想传递MYSQL*参量取而代之，请使用无符号整数mysql_field_count(MYSQL *mysql)。
描述
返回结果集中的行数。
注意，你可以从指向结果集的指针或指向连接句柄的指针获得行数。如果mysql_store_result()或mysql_use_result()返回NULL，应使用连接句柄（因而没有结果集指针）。在该情况下，可调用mysql_field_count()来判断mysql_store_result()是否生成了非空结果。这样，客户端程序就能采取恰当的行动，而不需要知道查询是否是SELECT语句（或类似SELECT的语句）。在下面的示例中，介绍了执行该操作的方式。
请参见25.2.13.1节，“为什么在mysql_query()返回成功后，mysql_store_result()有时会返回NULL”。
返回值
表示结果集中行数的无符号整数。
错误
无。
示例：
MYSQL_RES *result;
unsigned int num_fields;
unsigned int num_rows;

if (mysql_query(&mysql,query_string))
{
    // error
}
else // query succeeded, process any data returned by it
{
    result = mysql_store_result(&mysql);
    if (result)  // there are rows
    {
        num_fields = mysql_num_fields(result);
        // retrieve rows, then call mysql_free_result(result)
    }
    else  // mysql_store_result() returned nothing; should it have?
    {
        if (mysql_errno(&mysql))
        {
           fprintf(stderr, "Error: %s\n", mysql_error(&mysql));
        }
        else if (mysql_field_count(&mysql) == 0)
        {
            // query does not return data
            // (it was not a SELECT)
            num_rows = mysql_affected_rows(&mysql);
        }
    }
}
另一种可选方式是（如果你知道你的查询应返回结果集），使用检查“mysql_field_count(&mysql) is = 0”来替换mysql_errno(&mysql)调用。仅当出错时才应使用它。
25.2.3.47. mysql_num_rows()
my_ulonglong mysql_num_rows(MYSQL_RES *result)
描述
返回结果集中的行数。
mysql_num_rows()的使用取决于是否采用了mysql_store_result()或mysql_use_result()来返回结果集。如果使用了mysql_store_result()，可以立刻调用mysql_num_rows()。如果使用了mysql_use_result()，mysql_num_rows()不返回正确的值，直至检索了结果集中的所有行为止。
返回值
结果集中的行数。
错误
无。






OSI Model
Data unit	Layer	Function
Host
layers	Data	7. Application	Network process to application
6. Presentation	Data representation, encryption and decryption, convert machine dependent data to machine independent data
5. Session	Interhost communication, managing sessions between applications
Segments	4. Transport	End-to-end connections, reliability and flow control
Media
layers	Packet/Datagram	3. Network	Path determination and logical addressing
Frame	2. Data link	Physical addressing
Bit	1. Physical	Media, signal and binary transmission


nm xxxx.so
    




insert into t_package_info (id, frame_len) value (9,299)




    
cat /proc/cpuinfo | grep processor | wc -l
    
cat /proc/cpuinfo | grep physical | uniq -c
 




vim--------------------------------

jump to line num: linenum + gg
jump to line tail: $
jump to line head: 0
search:       /, next: n, previous: N

    
   







/*************************************************************************
%	跳转到配对的括号去
[[	跳转到代码块的开头去(但要求代码块中'{'必须单独占一行)
gD	跳转到局部变量的定义处
''	跳转到光标上次停靠的地方, 是两个', 而不是一个"
mx	设置书签,x只能是a-z的26个字母
`x	跳转到书签处("`"是1左边的键)
>	增加缩进,"x>"表示增加以下x行的缩进
<	减少缩进,"x<"表示减少以下x行的缩进
光标移动指令

1. h 左

2. l 右

3. k 上

4. j 下

5. Ctrl+f 向前翻页

6.Ctrl+b 向后翻页
7. 0  行首

8. 移至行首第一个非空白字

9. $ 行尾

10.G 文档尾部

11.gg 文档首部
12.w 移至一个word的首部

13.e 移至一个word的字尾

15.b 移至前一个自首

16.L 光标移动至屏幕中间的第一个非空字元

17.：n 移至第n行行首
18.) 移至下一个句子首部

19.( 移至上一个句子首部

20.} 移至下一个段落首部

21.} 移至上一个段落首部

 

进入插入命令
1. i 在光标的字之前

2. a 在光标的字之后

3. o 光标的下一行

4. I 在光标的行首

5. A 在光标的行尾

6. O 在光标的上一行

7. J 将下一行整行接至本行

 

 删除指令
1. x 删除光标所在的字元

2. X 删除光标之前的字元

3. dd 删除整行

4. dw 删除一个word

5. dG 删除至文档尾

6. dgg 删除至档首

7. D 删除至行尾

8.d0 删除至行首

 

 取代及还原
1. r 取代光标所在的字元

2. R 进入取代模式

3. cc 取代整行

4. cw 取代一个word

5. ~ 光标所在的字元大小写互换

6. C 取代至行尾

7. c0 取代至行首 

8. s 替换一个字元为字符串

9. u undo

10. ctrl+r redo


文字排布

 1.:ce(nter) 文字居中

2,:right  文字靠右

3.le（ft）文字靠左


复制指令（yank）
1. yy 复制整行

2. 2yy 复制

2行3. y^ 复制至行首

4. y$ 复制至行尾

5. yw 复制一个word

6. y2w 复制2个word

7. yG 复制至档尾

8. y1G 复制至档首
9. p 粘贴至游标后

10.P 粘贴至光标前


搜寻

 1. / +要找的单词+enter,n向下，N向上


替换

[range]s/pattern/string/[c,e,g,i]

range 表示的是范围，1，7第一行到第七行，$整篇文章 %目前编辑的，#前一次编辑的pattern 要被替换的字串string 取代之的字串c 每次替换前询问e 不提示errorg 不询问，整行替换i 不区分大小写
 

书签功能 
  在文章某处marks ，然后跑到其他地方去了，这是呼叫mark 又回到了原处1. mx x为26个小写字母，表示光标这被mark了2.`x 回到x标志的位置3. 'x 回到x标志的行首

多档案编辑
1. :n 编辑下一个档案
2. :2n 编辑下二个档案
3. :N 编辑前一个档案
4. :e 档案名，tab自动补全
5. :bn 编辑次一个
6. :bp 编辑前一个
7. :bl 编辑最后一个

离开
 1. :q 
2. :q! 强制离开
3. :wq 存档离开
4. :x 存档离开
5. :w 名字 另存为
6. :qa 离开整个vim a= all

 
视窗操作
 1. ctrl+w n（new） 开一个新窗口 w=window
2. ctrl+w s (spli) 开一个新窗口，原档案分离为两个
3. ctrl+w f 开一个新窗口，并编辑光标所在的word为新档案名字
4. ctlr+w q 结束分离出来的窗口
5. ctrl+w o(only)使光标所在的窗口显示其他窗口隐藏
6. ctrl+w j 移至下窗口
7. ctrl+w k 移至上窗口
8. :sp 另外开一个窗口来编辑档案
*************************************************************************/






javah -classpath . -jni  com.yuandian.apm.backtrack.jni.DataPacketAnalysis
   
Java类型     符号 
boolean  	Z  
byte		B  
char 		C   
short  		S  
int  		I  
long  		J   
float  		F   
double 		D   
														
objects对象  Lfully-qualified-class-name;        L类名; 
Arrays数组  [array-type [数组类型  
methods方法                   (argument-types)return-type(参数类型)返回类型  


usermod -g group username
   

-E
--export-dynamic
           When  creating  a  dynamically  linked  executable, add all symbols to the dynamic symbol table.  The
           dynamic symbol table is the set of symbols which are visible from dynamic objects at run time.
           
           If you do not use this option, the dynamic symbol table will  normally  contain  only  those  symbols
           which are referenced by some dynamic object mentioned in the link.
           
	           If  you use "dlo
pen" to load a dynamic object which needs to refer back to the symbols defined by the
           program, rather than some other dynamic object, then you will probably need to use this  option  when
           linking the program itself.
   
15:23 2013-5-4
   auto eth0
   iface eth0 inet dhcp
      
   ifconfig ethx xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx up
   
ed->fields = (char **)malloc(sizeof(char *) * fields->fields->len);	
   
               
   time_t lt;
   lt = time(NULL);
   
   implementation principle and security mechanism
   
    
22:37 2013-5-24
    传输层：     数据段(segment)或报文
    网络层:      分组(数据包（packet))
    数据链路层:  数据帧(Frame)
    物理层:	 bit
    
    
/home/xuzhenjie/opt/wireshark/bin/tshark -r /home/tmp/capture_00001_20130522102224.cap -T fields -e frame.number -e frame.protocols

ll -tr




由操作型数据创建而来的 OLAP 结构被称之为 OLAP 数据集（OLAP cube）。OLAP 数据集中可能包含每个查询的所有答复。OLAP 数据集采用的星型模式指：事实表列出关键事实，然后由中心进行查询的一种方式。大量的维度表与事实表相链接。为避免计算所有可能的数集，所以只对预先确定的数进行完全的计算，其它的作为备用。



星型架构是一种非正规化的结构，多维数据集的每一个维度都直接与事实表相连接，不存在渐变维度，所以数据有一定的冗余

15:49 2013-6-11
   
   vmware-vdiskmanager.exe -x 30Gb 									e:\elon\vmsys\ubu
ntu\Ubuntu.vmdk



